<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初识Kafka</title>
      <link href="/2019/08/27/%E5%88%9D%E8%AF%86kafka/"/>
      <url>/2019/08/27/%E5%88%9D%E8%AF%86kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>在微服务的架构设计中我们一般都会考虑服务之间互相调用的问题，如何做到更好的解耦设计。在秒杀的系统中会使用异步处理的方式来设计高并发、低延迟的系统架构。提到这些相信大家都会想到使用<code>MQ(消息队列)</code>来处理这些问题。</p><p><code>MQ(消息队列)</code> 是跨进程通信方式之一，可理解为异步RPC，上游系统对调用结果的态度往往是重要不紧急。使用消息队列有几个好处：<code>业务解耦</code>、<code>流量削峰</code>、<code>灵活扩展</code></p><h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>现在业界主流的MQ有很多，比如：<code>ActiveMQ</code>、<code>RabbitMQ</code>、<code>RocketMQ</code>、<code>Kafka</code> 等，那么我们在技术选型中该怎么选择呢？</p><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单击吞吐量</td><td>万级，吞吐量比RocketMQ和Kafka要低一个数量级</td><td>万级，吞吐量比RocketMQ和Kafka要低一个数量级</td><td>10万级，RocketMQ也是可以支撑高吞吐的一种MQ</td><td>10万级别，这是Kafka最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算，日志采集等场景。</td></tr><tr><td>topic数量对吞吐量的影响</td><td></td><td></td><td>topic可以达到几百，几千个的级别，吞吐量会较小幅度的下降，这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic。</td><td>topic从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，Kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多机器资源。</td></tr><tr><td>时效性</td><td>ms级</td><td>微妙级，这是rabbitMq的一大特点，延迟是最低的</td><td>ms级</td><td>延迟在ms以内</td></tr><tr><td>可用性</td><td>高，基于主从框架实现高可用性</td><td>高，基于主从架构实现高可用性</td><td>非常高，分布式架构</td><td>非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td></td><td>经过参数优化配置可以做到0丢失</td><td>经过参数优化配置，消息可以做到0丢失</td></tr><tr><td>功能支持</td><td>MQ领域的功能及其完备</td><td>基于erlang开发，所以并发能力很强，性能及其好，延时很低</td><td>MQ功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td></tr><tr><td>优劣势总结</td><td>非常成熟，功能强大，在业内大量的公司以及项目中都有应用。              偶尔会有较低概率的丢失消息。              而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ维护越来越少，几个月才发布一个版本。              而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用。</td><td>erlang语言开发，性能及其好，延时很低：吞吐量到万级，MQ功能比较完备，而且开源提供的管理界面非常棒，用起来很好用。社区相对比较活跃，几乎每个月都发布几个版本。在国内公司用             rabbitmq也比较多一些                             但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。                             而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。                            而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。</td><td>接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障                             日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景                             而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控                             社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码                            还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的</td><td>kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展                             同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量                             而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略                            这个特性天然适合大数据实时计算以及日志收集</td></tr></tbody></table><p>综上比较，可以看出<code>RocketMQ</code>和<code>Kafka</code> 优势较为明显，其实对于大多数的服务架构来说，<code>吞吐量</code> 和 <code>消息可靠性</code> 是我们选型中考虑较多的因素。接下来我们就一起来了解下<code>Kafka</code> 相关的内容</p><h1 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h1><p>Kafka 是Apache旗下的开源产品，</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://maimai.cn/article/detail?fid=1306743575&amp;efid=uZn37YZ12xn5DazBUNqs8Q&amp;from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">https://maimai.cn/article/detail?fid=1306743575&amp;efid=uZn37YZ12xn5DazBUNqs8Q&amp;from=singlemessage&amp;isappinstalled=0</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/zxPz_aFEMrshApZQ727h4g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zxPz_aFEMrshApZQ727h4g</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MQ </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM - 垃圾回收之世代垃圾收集过程</title>
      <link href="/2019/08/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%20-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B9%8B%E4%B8%96%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/08/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%20-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B9%8B%E4%B8%96%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://binchencoder.github.io/2019/08/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%20-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">深入理解 - 垃圾回收</a> 中我们详细讲解了JVM垃圾回收的机制、垃圾收集算法以及各种垃圾回收器的原理和优缺点。</p><p>通过上一篇文章我们知道现在主流的垃圾回收器都采用了<code>分代收集算法</code>，本文我们就来详细讲解下垃圾回收器是如何进行分代收集垃圾的</p><h2 id="JVM分代"><a href="#JVM分代" class="headerlink" title="JVM分代"></a>JVM分代</h2><p>分代其实就是将堆分成几个部分，分别是新生代、老年代和永久代</p><p><img src="/2019/08/24/深入理解JVM - 垃圾回收之世代垃圾收集过程/hotspot-heap-structure.png" alt></p><blockquote><p>新对象会被分配在<strong>新生代</strong>内存。一旦新生代内存满了，就会开始对死掉的对象，进行所谓的<code>小型垃圾回收</code>过程。一旦新生代内存里，死掉的越多，回收过程就越快；至于那些还活着的对象，此时就会老化，并最终老到进入老年代内存。</p><p>Stop the World 事件 —— 小型垃圾回收属于一种叫 “Stop the World” 的事件。在这种事件发生时，所有的程序线程都要暂停，直到事件完成（比如这里就是完成了所有回收工作）为止。</p></blockquote><blockquote><p><strong>老年代</strong>用来保存长时间存活的对象。通常设置一个阈值，当达到该年龄时，年轻代对象会被移动到老年代。最终老年代也会被回收。这个事件称为<code>Major GC</code>。</p><p>Major GC 也会触发STW（Stop the World）。通常，Major GC会慢很多，因为它涉及到所有存活对象。所以，对于响应性的应用程序，应该尽量避免Major GC。还要注意，Major GC的STW的时长受年老代垃圾回收器类型的影响。</p></blockquote><blockquote><p><strong>永久代</strong> 包含JVM用于描述应用程序中类和方法的元数据。永久代是由JVM在运行时根据应用程序使用的类来填充的。此外，Java SE类库和方法也存储在这里。</p><p>如果JVM发现某些类不再需要，并且其他类可能需要空间，则这些类可能会被回收。</p></blockquote><h2 id="世代垃圾回收过程"><a href="#世代垃圾回收过程" class="headerlink" title="世代垃圾回收过程"></a>世代垃圾回收过程</h2><p>现在我们已经理解了为什么堆被分成不同的代，接下来我们一起来看看这些空间是如何相互作用，JVM中的对象是如何分配和老化的</p><ol><li><p><strong>首先，将任何新对象分配给Eden空间，两个survivor空间都是空的</strong><br><img src="/2019/08/24/深入理解JVM - 垃圾回收之世代垃圾收集过程/object-allocation.png" alt></p></li><li><p><strong>当eden空间填满时，会触发轻微的垃圾收集</strong><br><img src="/2019/08/24/深入理解JVM - 垃圾回收之世代垃圾收集过程/filling-eden-space.png" alt></p></li><li><p><strong>引用的对象被移动到第一个survivor空间，清除eden空间时，将删除未引用的对象</strong><br><img src="/2019/08/24/深入理解JVM - 垃圾回收之世代垃圾收集过程/coping-referenced-objects.png" alt></p></li><li><p>在下一次的Minor GC中，Eden区也会做同样的操作。删除未被引用的对象，并将被引用的对象移动到Survivor区。然后，他们被移动到了第二个Survivor区（S1）。此外，第一个Suvivor区（S0）中，在上一次Minor GC幸存的对象，会增加年龄，并被移动到S1中。待所有幸存对象都被移动到S1后，S0和Eden区会被清空。注意，Survivor区中有了不同年龄的对象。<br><img src="/2019/08/24/深入理解JVM - 垃圾回收之世代垃圾收集过程/object-aging.png" alt></p></li><li><p>在下一次的Minor GC中，会重复同样的动作。不过，这一次Survivor区会交换。被引用的对象移动到S0，幸存的对象增加年龄。Eden区和S1被清空<br><img src="/2019/08/24/深入理解JVM - 垃圾回收之世代垃圾收集过程/additional-aging.png" alt></p></li><li><p>在较小的GC之后，当老化的物体达到一定的年龄阈值（在该示例中为8）时，它们从年轻一代晋升到老一代。<br><img src="/2019/08/24/深入理解JVM - 垃圾回收之世代垃圾收集过程/promotion1.png" alt></p></li></ol><p>随着较小的GC持续发生，物体将继续被推广到老一代空间。<br><img src="/2019/08/24/深入理解JVM - 垃圾回收之世代垃圾收集过程/promotion2.png" alt></p><p>所以这几乎涵盖了年轻一代的整个过程。 最终，将主要对老一代进行GC，清理并最终压缩该空间。<br><img src="/2019/08/24/深入理解JVM - 垃圾回收之世代垃圾收集过程/gc-process-summary.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM - 垃圾回收</title>
      <link href="/2019/08/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%20-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2019/08/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%20-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://binchencoder.github.io/2019/08/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%20-%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">JVM内存结构</a> 中我们详细讲解了JVM中的内存是如何分布和组成的。</p><p>我们已经知道JVM内存结构主要有三大块：<code>堆内存</code>、<code>方法区</code>和<code>栈内存</code>，而堆又是JVM中占用内存最大的一块，但是堆占用的空间也不是无限的(在JVM中会有参数来进行控制)，在程序运行的过程中，会不断的产生对象，导致堆的内存空间减少，这时我们会想到一定有一种机制来进行回收。接下来我们就一起来看看JVM是如何回收不再使用的对象空间的。</p><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h4 id="Java垃圾回收主要关注堆"><a href="#Java垃圾回收主要关注堆" class="headerlink" title="Java垃圾回收主要关注堆"></a>Java垃圾回收主要关注堆</h4><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/垃圾回收机制.png" alt="image"></p><blockquote><p>Java内存运行时区域中的程序计数器、虚拟机栈、本地方法栈 都是线程私有的，因此它们的生命周期与线程的生命周期是一样的；栈中的栈帧随着方法的进入和退出有条无紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化）。因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题，因此方法结束或者线程结束时，内存自然就随着回收了。</p></blockquote><p>而Java堆不一样，一个接口中的多个实现类需要的内存不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。</p><h4 id="判断需要被回收对象的方法"><a href="#判断需要被回收对象的方法" class="headerlink" title="判断需要被回收对象的方法"></a>判断需要被回收对象的方法</h4><p><strong>引用计数法</strong></p><blockquote><p>该方法简单高效，缺点是无法解决对象之间相互循环引用的问题</p></blockquote><p><strong>可达性分析法</strong></p><blockquote><p>解决了<code>引用计数法</code> 循环引用的问题</p></blockquote><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/可达性分析法.png" alt="image"></p><p>不可达的对象将暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p><strong>一共有四种：</strong> <code>标记-清除算法</code>、<code>复制算法</code>、<code>标记-整理算法</code>、<code>分代收集算法</code></p><h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a><strong>标记-清除算法(Mark-Sweep)</strong></h3><p>这是最基础的算法，分为“标记” 和 “清除” 两个阶段。首先<strong>标记</strong>出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</p><p><strong>缺点：</strong></p><ul><li>效率问题</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致以后需要分配较大的对象空间时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li></ul><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/标记-清除.png" alt="image"></p><h3 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a><strong>复制算法(Copying)</strong></h3><blockquote><p>现在的商业虚拟机都采用这种算法来回收新生代</p></blockquote><p>复制算法是为了为了解决效率的问题，它将可用内存分为大小相等的两块。每次只使用其中的一块。当这一块的内存用完了，就将还活着的对象复制到另外一块上，然后把已使用的内存空间一次性清理掉。</p><p>这个算法的缺点是可用内存缩小为原来的一半</p><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/复制.png" alt="image"></p><h3 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a><strong>标记-整理算法(Mark-Compact)</strong></h3><p>复制算法在对象存活率较高的情况下要进行较多的复制操作，效率会降低。</p><p>复制算法并不适用于老年代，所以才有了<code>“标记-整理”</code> 算法，标记的过程与<code>“标记-清除”</code> 是一样的，第二步不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端便捷以外的内存</p><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/标记-整理.png" alt="image"></p><h3 id="分代收集算法-Generational-Collection"><a href="#分代收集算法-Generational-Collection" class="headerlink" title="分代收集算法 (Generational Collection)"></a><strong>分代收集算法 (Generational Collection)</strong></h3><p>现代商业虚拟机的垃圾收集都采用这一算法，它是根据对象存活周期的不同将内存划分为几块并采用不同的垃圾收集算法。</p><p>一般将Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以根据各个年代的特点采用最适当的收集算法。</p><ul><li>新生代：每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制法，只需要付出少量存活对象的复制成本就可以完成收集</li><li>老年代：因为对象存活率高，没有额外空间对它进行分配担保，那就必须使用<strong>标记-清理</strong> 或者 <strong>标记-整理</strong> 算法来进行回收</li></ul><h2 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h2><p>如果垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现</p><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/垃圾收集器分类.png" alt="image"></p><h3 id="Serial收集器-串行收集器"><a href="#Serial收集器-串行收集器" class="headerlink" title="Serial收集器(串行收集器)"></a>Serial收集器(串行收集器)</h3><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/serial.png" alt="image"></p><blockquote><p>这是一个单线程的收集器，它在进行垃圾收集时，必须暂停掉其他所有的工作线程，直到它收集结束（Stop The World）</p></blockquote><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/serial-old.png" alt="image"></p><p>这是Serial收集器是老年代版本，也是一个单线程，使用 <strong>标记-整理</strong> 算法。</p><h3 id="ParNew收集器-串行收集器"><a href="#ParNew收集器-串行收集器" class="headerlink" title="ParNew收集器(串行收集器)"></a>ParNew收集器(串行收集器)</h3><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/parnew.png" alt="image"></p><blockquote><p>ParNew收集器是Serial收集器的多线程版本</p></blockquote><p>除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。</p><h3 id="Parallel-Scavenge收集器-并行收集器"><a href="#Parallel-Scavenge收集器-并行收集器" class="headerlink" title="Parallel Scavenge收集器(并行收集器)"></a>Parallel Scavenge收集器(并行收集器)</h3><p>这是一个新生代收集器，使用复制算法，又是并行的多线程收集器。Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量(Througput)</p><blockquote><p>吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%</p></blockquote><h3 id="Parallel-Old收集器-并行收集器"><a href="#Parallel-Old收集器-并行收集器" class="headerlink" title="Parallel Old收集器(并行收集器)"></a>Parallel Old收集器(并行收集器)</h3><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/parallel-old.png" alt="image"></p><p>这是Parallel Scavenge收集器的老年代版本，使用多线程和<strong>标记-整理算法</strong></p><p><strong>Sample:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 </span><br><span class="line">-XX:+UseParallelOldGC MaxGCPauseMillis=100 -XX:MaxGCPauseMillis=100</span><br></pre></td></tr></table></figure><h3 id="CMS收集器-Concurrent-Mark-Sweep-并发标记扫描"><a href="#CMS收集器-Concurrent-Mark-Sweep-并发标记扫描" class="headerlink" title="CMS收集器(Concurrent Mark Sweep 并发标记扫描)"></a>CMS收集器(Concurrent Mark Sweep 并发标记扫描)</h3><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/cms.png" alt="image"></p><p>这是一种以获取最短回收停顿时间为目标的收集器</p><p><strong>步骤：</strong></p><ol><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ol><blockquote><p>初始标记、重新标记这两个步骤仍然需要”Stop The World”。</p></blockquote><p><strong>优点：</strong> 并发收集，低停顿</p><p><strong>缺点：</strong></p><ol><li>导致吞吐量降低：CMS收集器对CPU资源比较敏感，在并发阶段会占用一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量降低</li><li>无法处理浮动垃圾：可能出现”Concurrent Mode Failure”失败而导致另一次 Full GC（新生代和老年代同时回收） 的产生</li><li>产生空间碎片：空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC </li></ol><p><strong>Sample:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k-XX:ParallelGCThreads=20  -XX:+UseConcMarkSweepGC </span><br><span class="line">-XX:+UseParNewGC  -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</span><br></pre></td></tr></table></figure><h3 id="G1收集器（Garbage-First）【重点】"><a href="#G1收集器（Garbage-First）【重点】" class="headerlink" title="G1收集器（Garbage-First）【重点】"></a>G1收集器（Garbage-First）【重点】</h3><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/g1.png" alt="image"></p><p>G1 是一款面向服务端应用的垃圾收集器</p><p><strong>步骤：</strong></p><ol><li>初始标记（Initial Marking）</li><li>并发标记（Concurrent Marking）</li><li>最终标记（Final Marking）</li><li>筛选回收（Live Data Counting and Evacuation）</li></ol><p><strong>优点：</strong></p><ol><li>并行与并发：G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行</li><li>分代收集：能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果</li><li>空间整合：G1从整体上看是基于“标记-整理”算法实现的，从局部（两个 Region 之间）上来看是基于“复制”算法实现的。这意味着G1运行期间不会产生内存碎片，收集后能提供规整的内存空间</li><li>可预测的停顿：可建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒</li></ol><h2 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h2><p>阅读 GC 日志是处理 Java 虚拟机内存问题的基础技能，它只是一些人为确定的规则，没有太多技术含量。</p><p>每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的 GC 日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33.125</span>:[GC[DefNew:<span class="number">3324</span>K-＞<span class="number">152</span>K（<span class="number">3712</span>K），<span class="number">0.0025925</span> secs]<span class="number">3324</span>K-＞<span class="number">152</span>K（<span class="number">11904</span>K），<span class="number">0.0031680</span> secs]</span><br><span class="line"><span class="number">100.667</span>:[Full GC[Tenured:<span class="number">0</span> K-＞<span class="number">210</span>K（<span class="number">10240</span>K），<span class="number">0.0149142</span>secs]<span class="number">4603</span>K-＞<span class="number">210</span>K（<span class="number">19456</span>K），[Perm:<span class="number">2999</span>K-＞<span class="number">2999</span>K（<span class="number">21248</span>K）]，<span class="number">0.0150007</span> secs][Times:user=<span class="number">0.01</span> sys=<span class="number">0.00</span>，real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure><p>最前面的数字<code>33.125：</code> 和 <code>100.667：</code> 代表了 GC 发生的时间，这个数字的含义是从 Java 虚拟机启动以来经过的秒数。</p><p>GC 日志开头的 <code>[GC</code> 和 <code>[Full GC</code> 说明了这次垃圾收集的停顿类型，而不是用来区分新生代 GC 还是老年代 GC 的。</p><p>如果有 <code>Full</code>，说明这次 GC 是发生了 Stop-The-World 的，例如下面这段新生代收集器 ParNew 的日志也会出现 <code>[Full GC</code>（这一般是因为出现了分配担保失败之类的问题，所以才导致 STW）。如果是调用 System.gc() 方法所触发的收集，那么在这里将显示 <code>[Full GC（System）</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC <span class="number">283.736</span>:[ParNew:<span class="number">261599</span>K-＞<span class="number">261599</span>K（<span class="number">261952</span>K），<span class="number">0.0000288</span> secs]</span><br></pre></td></tr></table></figure><p>接下来的 <code>[DefNew</code>、<code>[Tenured</code>、<code>[Perm</code> 表示 GC 发生的区域，这里显示的区域名称与使用的 GC 收集器是密切相关的，例如上面样例所使用的 Serial 收集器中的新生代名为 “Default New Generation”，所以显示的是 <code>[DefNew</code>。如果是 ParNew 收集器，新生代名称就会变为 <code>[ParNew</code>，意为 “Parallel New Generation”。如果采用 <code>Parallel Scavenge</code> 收集器，那它配套的新生代称为 <code>PSYoungGen</code>，老年代和永久代同理，名称也是由收集器决定的。</p><p>后面方括号内部的 <code>3324K-＞152K（3712K）</code>含义是GC 前该内存区域已使用容量 -＞ GC 后该内存区域已使用容量 （该内存区域总容量）。而在方括号之外的 <code>3324K-＞152K（11904K）</code> 表示 <code>GC 前 Java 堆已使用容量 -＞ GC 后 Java 堆已使用容量 （Java 堆总容量）</code></p><p>再往后，<code>0.0025925 secs</code> 表示该内存区域 GC 所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如 <code>[Times:user=0.01 sys=0.00，real=0.02 secs]</code> ，这里面的 user、sys 和 real 与 Linux 的 time 命令所输出的时间含义一致，分别代表用户态消耗的 CPU 时间、内核态消耗的 CPU 事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）</p><p>CPU 时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘 I/O、等待线程阻塞，而 CPU 时间不包括这些耗时，但当系统有多 CPU 或者多核的话，多线程操作会叠加这些 CPU 时间，所以读者看到 user 或 sys 时间超过 real 时间是完全正常的</p><h2 id="垃圾回收器的选择"><a href="#垃圾回收器的选择" class="headerlink" title="垃圾回收器的选择"></a>垃圾回收器的选择</h2><p><strong>决定因素：</strong></p><ol><li>应用程序的场景</li><li>硬件的制约</li><li>吞吐量的需求</li></ol><p>串行垃圾回收是最简单，但是效率最低的垃圾回收器。适用于控制台的单线程程序，简单任务。</p><p>并行垃圾回收器是64bit server默认的垃圾回收器，一般我们工作和产线上如果不配置，默认都是并行垃圾回收。对于一般的不要求吞吐的应用，并且硬件资源不是太充足的情况下，并行垃圾回收器差不多能满足需求。</p><p><strong>重点</strong></p><p>CMS垃圾回收器是对并行垃圾回收器的一个优化，它以CPU和系统资源为代价，换区GC的延迟。不会一GC就STW，而是根据情况STW。一定程度上是资源换取速度。</p><p>G1垃圾回收器是针对大Heap的垃圾回收器，如果heap分配的足够大，分的region的优先级回收策略会优先清理垃圾多的region。并且减少了内存空间碎片，分配大对象时不会因为无法找到连续的内存空间而提前触发下一次GC。</p><table><thead><tr><th><strong>Option</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>Serial Garbage Collector 串行垃圾回收器</td></tr><tr><td>-XX:+UseParallelGC</td><td>Parallel Garbage Collector并行垃圾回收器</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>CMS Garbage Collector并发标记垃圾回收器</td></tr><tr><td>-XX:ParallelCMSThreads=</td><td>CMS Collector – number of threads to use 并发标记垃圾回收器使用的线程数，通常是cpu个数</td></tr><tr><td>-XX:+UseG1GC</td><td>G1 Gargbage Collector 使用G1垃圾回收器</td></tr></tbody></table><h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><p><img src="/2019/08/23/深入理解JVM - 垃圾回收/垃圾收集器参数1.png" alt><br><img src="/2019/08/23/深入理解JVM - 垃圾回收/垃圾收集器参数2.png" alt></p><h2 id="查看垃圾回收器"><a href="#查看垃圾回收器" class="headerlink" title="查看垃圾回收器"></a>查看垃圾回收器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chenbindeMacBook-Pro:BazelWorkspace chenbin$ java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=268435456 -XX:MaxHeapSize=4294967296 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span><br><span class="line">java version &quot;1.8.0_112&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_112-b16)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.112-b16, mixed mode)</span><br></pre></td></tr></table></figure><h2 id="名词术语"><a href="#名词术语" class="headerlink" title="名词术语"></a>名词术语</h2><ol><li><strong>Full GC：</strong>新生代和老年代同时回收</li></ol><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/czwbig/p/11127159.html" target="_blank" rel="noopener">https://www.cnblogs.com/czwbig/p/11127159.html</a></li><li><a href="https://www.oschina.net/translate/java-gc" target="_blank" rel="noopener">https://www.oschina.net/translate/java-gc</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM - 内存结构</title>
      <link href="/2019/08/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%20-%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2019/08/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%20-%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每个使用Java的开发者都知道Java字节码是在<code>JRE</code>中运行，JRE由Java API和JVM组成，JVM通过类加载器(Class Loader)加载Java应用，并通过Java API进行执行。</p><p><code>JVM</code>则是JRE中的核心组成部分，承担分析和执行Java字节码的工作，而Java开发人员通常并不需要深入了解JVM运行情况就可以开发出大型应用和类库。尽管如此，相信所有的Java开发人员在工作中都会遇到这样的困惑：该为堆内存设置多大的空间？OutOfMemoryError的异常到底涉及到运行时数据的哪块区域，遇到了该如何解决？</p><p>在Java成长的道路上，对JVM调优是一项最基本的技能。如果你是一名资深的Java开发人员，一定会接到解决服务器性能的任务，而深入理解JVM则是解决这一问题的根本。</p><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p><img src="/2019/08/21/深入理解JVM - 内存结构/JVM内存结构.png" alt="JVM的内存结构"></p><blockquote><ul><li><p>JVM内存结构主要有三大块：<code>堆内存</code>、<code>方法区</code>和<code>栈</code>。堆内存是JVM中最大的一块由<strong>年轻代</strong>和<strong>老年代</strong> 组成。而年轻代内存又被分成三部分，<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>,默认情况下年轻代按照8:1:1的比例来分配的;</p></li><li><p>方法区存储<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名 <code>Non-Heap(非堆)</code>;</p></li><li><p>栈又分为<code>虚拟机栈</code>和<code>本地方法栈</code>，主要用于方法的执行。</p></li></ul></blockquote><p><img src="/2019/08/21/深入理解JVM - 内存结构/内存及调优参数.png" alt="内存及调优参数"></p><blockquote><p>上图详细标注了如何通过参数来控制各区域的内存大小</p></blockquote><p><strong>控制参数</strong></p><ul><li>-Xms 设置堆的最小空间大小</li><li>-Xmx 设置堆的最大空间大小</li><li>-XX:NewSize 设置新生代最小空间大小</li><li>-XX:MaxNewSize 设置新生代最大空间大小</li><li>-XX:PermSize 设置永久代最小空间大小</li><li>-XX:MaxPermSize 设置永久代最大空间大小</li><li>-Xss 设置每个线程的堆栈大小</li></ul><p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制</p><blockquote><p>老年代空间大小 = 堆空间大小 - 年轻代大空间大小</p></blockquote><h2 id="Java运行时数据区"><a href="#Java运行时数据区" class="headerlink" title="Java运行时数据区"></a>Java运行时数据区</h2><p>Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域，如图：</p><p><img src="/2019/08/21/深入理解JVM - 内存结构/runtime data area.png" alt></p><h3 id="Java堆-Heap"><a href="#Java堆-Heap" class="headerlink" title="Java堆(Heap)"></a>Java堆(Heap)</h3><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中<strong>最大</strong>的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，<strong>几乎所有的对象实例都在这里分配内存。</strong></p><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做<strong>“GC堆”</strong>。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：<strong>新生代</strong>和<strong>老年代</strong>；再细致一点的有<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>等。</p><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p><p>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。</p><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 </p><h3 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h3><blockquote><p>指向当前线程正在执行的字节码指令。是线程私有的</p></blockquote><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 </p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 </p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p><p><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p><h3 id="JVM栈-JVM-Stack"><a href="#JVM栈-JVM-Stack" class="headerlink" title="JVM栈(JVM Stack)"></a>JVM栈(JVM Stack)</h3><blockquote><p><strong>包括<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>返回地址</code></strong></p></blockquote><ul><li>局部变量表：包含了方法执行过程中的所有变量。局部变量数组所需要的空间在编译期间完成分配，在方法运行期间不会改变局部变量数组的大小。</li><li>返回值：如果有返回值的话，压入调用者栈帧中的操作数栈中，并且把PC的值指向 方法调用指令 后面的一条指令地址。</li><li>操作数栈：操作变量的内存模型。操作数栈的最大深度在编译的时候已经确定（写入方法区code属性的max_stacks项中）。操作数栈的的元素可以是任意Java类型，包括long和double，32位数据占用栈空间为1，64位数据占用2。方法刚开始执行的时候，栈是空的，当方法执行过程中，各种字节码指令往栈中存取数据。</li><li>动态链接：每个栈帧都持有在运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。</li></ul><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，<strong>它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型</strong>：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong></p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><h3 id="本地方法栈-Native-Method-Stacks"><a href="#本地方法栈-Native-Method-Stacks" class="headerlink" title="本地方法栈(Native Method Stacks)"></a>本地方法栈(Native Method Stacks)</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<strong>本地方法栈则是为虚拟机使用到的Native方法服务。</strong>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识Bazel</title>
      <link href="/2019/08/16/%E8%AE%A4%E8%AF%86Bazel/"/>
      <url>/2019/08/16/%E8%AE%A4%E8%AF%86Bazel/</url>
      
        <content type="html"><![CDATA[<h1 id="Bazel入门"><a href="#Bazel入门" class="headerlink" title="Bazel入门"></a>Bazel入门</h1><p>最近一直在研究网关这玩意，想借鉴我们公司的网关架构自己实现一下。思路是引入grpc-gateway，只是在这套系统的基础上增加一些定制的功能，如：负载均衡，权限验证，API参数检查。因为grpc-gateway采用的是Bazel来构建的，所以我要实现的网关也必须是用Bazel来构建。虽然在公司里接触过Bazel，但那也是在比较完善的平台上照葫芦画瓢。</p><p>为了完成自己的目标，只能硬着头皮边学边用，边用边学了</p><h2 id="Bazel是什么"><a href="#Bazel是什么" class="headerlink" title="Bazel是什么"></a>Bazel是什么</h2><p>Bazel 是一个开源的构建和测试工具，类似于Make、Maven及Gradle。它使用一种人易于理解的高级构建语言。Bazel 支持多种开发语言的项目，能够基于多个平台来构建。Bazel支持跨多个制品库和大规模用户的大型代码仓库。</p><h2 id="为什么使用Bazel"><a href="#为什么使用Bazel" class="headerlink" title="为什么使用Bazel"></a>为什么使用Bazel</h2><p>Bazel具有以下优势：</p><ul><li><strong>高级构建语言</strong> Bazel使用一种抽象的、人易于理解的、语义级别的高级语言来描述项目的构建属性。与其他工具不同，Bazel基于库，二进制文件，脚本和数据集的概念进行操作，使您免于陷入将单个调用编写到编译器和链接器等工具的复杂性。</li><li><strong>Bazel高效可靠</strong> Bazel缓存以前完成的所有工作，并跟踪文件内容和构建命令的更改。通过这种方式，Bazel知道何时需要重建某些东西，并仅重建那些东西。为了进一步加快构建速度，您可以将项目设置为以并行和增量的方式构建。</li><li><strong>Bazel是跨平台的</strong> Bazel可以在Linux，macOS和Windows上运行。Bazel可以为同一个项目中的多个平台(包括桌面,服务器和移动设备)构建二进制文件和可部署软件包。</li><li><strong>Bazel扩展性强</strong> Bazel在使用100k+源文件处理构建时仍然保持良好的性能表现。它适用于多个制品存储库和10K用户规模。</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Bazel根据在称为工作空间(WORKSPACE)的目录中组织的源代码构建软件。工作空间中的源文件以包的嵌套层次结构进行组织，其中每个包都是包含一组相关源文件和一个BUILD文件的目录。BUILD文件指定可以从源构建哪些软件输出。</p><h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><p>工作空间是文件系统上的目录，每个工作空间目录都有一个名为WORKSPACE的文本文件，该文件可能为空(不建议这样做，至少定义一个name)，或者可能包含对构建输出所需的外部依赖项的引用。</p><p>Sample:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workspace(name = &quot;com_github_binchencoder_ease_gateway&quot;)</span><br></pre></td></tr></table></figure><h3 id="程序包"><a href="#程序包" class="headerlink" title="程序包"></a>程序包</h3><p>工作空间中代码组织的主要单元是包。包是相关文件的集合，以及它们之间的依赖关系的规范。每个程序包中包含一个BUILD文件，此文件中描述了此工具包的生成构建方式。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>生成的目标，每个target又可以作为另外一个规则的输入。<br>绝大部分的target属于两种基本类型中的一种，file和rule。另外，还有一种其他的target类型，package group。但是他们很少见。</p><p><img src="/2019/08/16/认识Bazel/target_tree.png" alt></p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>上述就是bazel最简单的描述，如果要学习bazel的详细进阶，可以访问起<a href="https://bazel.build" target="_blank" rel="noopener">官网</a>，官网上的文档非常详细，不过是英文的。</p><p>另外，我的github有几个更多的例子，可以进一步学习和理解bazel。</p><p>References:</p><ul><li><a href="https://bazel.build" target="_blank" rel="noopener">https://bazel.build</a></li><li><a href="https://github.com/grpc-ecosystem/grpc-gateway" target="_blank" rel="noopener">https://github.com/grpc-ecosystem/grpc-gateway</a></li><li><a href="https://github.com/binchencoder/ease-gateway" target="_blank" rel="noopener">https://github.com/binchencoder/ease-gateway</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bazel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存管理</title>
      <link href="/2019/08/11/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/11/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM内存管理"><a href="#JVM内存管理" class="headerlink" title="JVM内存管理"></a>JVM内存管理</h1><p>作为三大工业级别语言之一的JAVA如此受企业青睐有加，离不开她背后JVM的默默复出。只是由于JAVA过于成功以至于我们常常忘了JVM平台上还运行着像Clojure/Groovy/Kotlin/Scala/JRuby/Jython这样的语言。我们享受着JVM带来跨平台“一次编译到处执行”的便利和自动内存回收的安逸。</p><p>JVM是JAVA的核心基础，也是掌握JAVA语言的重难点，如果没有理解JVM的知识体系，就不要说自己是JAVA高手。最近我打算换工作，所以来重新回顾JVM的相关知识，为面试准备。JVM体系内知识点很多，通过以下关键词来简单概括下：</p><p><code>类结构</code>，<code>类加载器</code>，<code>加载</code>，<code>链接</code>，<code>初始化</code>，<code>双亲委派</code>，<code>热部署</code>，<code>隔离</code>，<code>堆</code>，<code>栈</code>，<code>方法区</code>，<code>计数器</code>，<code>内存回收</code>，<code>执行引擎</code>，<code>调优工具</code>，<code>JVMTI</code>，<code>JDWP</code>，<code>JDI</code>，<code>热替换</code>，<code>字节码</code>，<code>ASM</code>，<code>CGLIB</code>，<code>DCEVM</code></p><p>本文从JVM的内存结构入手，介绍JVM逻辑内存的分布和管理方式，同时列举常用的JVM调优工具和使用方法。</p><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><h3 id="逻辑分区"><a href="#逻辑分区" class="headerlink" title="逻辑分区"></a>逻辑分区</h3><p>JVM内存从应用逻辑上可分为如下区域：</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器，每个线程都需要一个程序计数器。在虚拟机的概念模型里（仅仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，<code>分支</code>、<code>循环</code>、<code>跳准</code>、<code>异常处理</code>、<code>线程恢复</code>等基础功能都需要依赖这个计数器来完成。</p><p>简单理解就是程序计数器保证了程序的正常执行。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>方法执行时创建栈帧(存储局部变量，操作栈，动态链接，方法出口)编译时期就能确定占用空间大小，线程请求的栈深度超过jvm运行深度时抛StackOverflowError，当jvm栈无法申请到空闲内存时抛OutOfMemoryError，<strong>通过-Xss,-Xsx来配置初始内存</strong></p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>执行本地方法，如操作系统native接口</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>存放对象的空间，<strong>通过-Xmx,-Xms配置堆大小</strong>，当堆无法申请到内存时抛OutOfMemoryError</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>存储类数据，常量，常量池，静态变量，通过MaxPermSize参数配置</p><h4 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h4><p>初始化一个对象，其引用存放于栈帧，对象存放于堆内存，对象包含属性信息和该对象父类、接口等类型数据（该类型数据存储在方法区空间，对象拥有类型数据的地址）</p><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h4><p>堆内存是运行时的数据区，从中分配所有的Java类实例和数组的内存，可以理解为目标应用依赖的对象。堆在JVM启动时创建，并在应用程序运行时可能会增大或减小。可以使用<code>-Xms`</code>选项指定堆的大小。堆可以是固定大小或可变大小，具体取决于垃圾收集策略。可以使用<code>-Xmx</code>选项设置最大堆大小。默认情况下，最大堆大小设置为64M。</p><p>JVM堆内存在物理上分为两部分：<code>新生代</code>和<code>老年代</code>。新生代是为分配新对象而保留堆空间。当新生代占用完时，Minor GC垃圾收集器会对新生代区域执行垃圾回收动作。其中在新生代中生活了足够长的所有对象被迁移到老生代，从而释放新生代空间以进行更多的对象分配。此垃圾收集称为<code>Minor GC</code>。新生代分分为三个子区域：<code>伊甸园Eden区</code>和两个<code>幸存区S0`</code>和<code>`S1</code>。</p><p><img src="/2019/08/11/JVM内存管理/JVM内存管理.png" alt></p><blockquote><p><strong>关于新生代空间：</strong></p></blockquote><ul><li>大多数新创建的对象都位于Eden区内存空间</li><li>当Eden区填满对象时，执行Minor GC并将所有幸存对象移动到其中一个幸存区空间</li><li>Minor GC还会检查幸存区对象并将其移动到其他幸存者空间，也即是幸存区总有一个是空的</li><li>在多次GC后还存活的对象被移动到老年代内存空间。至于经过多少次GC晋升老年代则由参数配置，通常为15</li></ul><p>当老年区填满时，老年区同样会执行垃圾回收。老年区还包含那些经过多Minor GC后还存活的长寿对象。垃圾收集器在老年代内存中执行的垃圾回收称为Major GC，通常需要更长的时间。</p><blockquote><p>Full GC ？？？</p></blockquote><h4 id="非堆内存"><a href="#非堆内存" class="headerlink" title="非堆内存"></a>非堆内存</h4><p>JVM堆以外的内存称为非堆内存。也即是JVM自身预留的内存区域，包含JVM缓存空间，类结构如常量池、字段和方法数据，方法，构造方法。类非堆内存的默认最大大小为64MB。可以用 -XX: MaxPermSize VM选项更改此选项，非堆内存通常包含如下性质的区域空间：</p><ul><li>元空间（Metaspace）</li></ul><p>在Java 8以上版本已经没有Perm Gen这块区域了，这也意味着不会再由关于“java.lang.OutOfMemoryError：PermGen”内存问题存在了。与驻留在Java堆中的Perm Gen不同，Metaspace不是堆的一部分。类元数据多数情况下都是从本地内存中分配的。默认情况下，元空间会自动增加其大小(直接又底层操作系统提供)，而Perm Gen始终具有固定的上限。可以使用两个新标志来设置Metaspace的大小，它们是：<code>“ - XX：MetaspaceSize ”和“ -XX：MaxMetaspaceSize ”</code>。Metaspace背后的含义是类的生命周期及其元数据与类加载器的生命周期相匹配。也就是说，只要类加载器处于活动状态，元数据就会在元数据空间中保持活动状态，并且无法释放。</p><ul><li>代码缓存</li></ul><p>运行Java程序时，它以分层方式执行代码。在第一层，它使用客户端编译器（C1编译器）来编译代码。分析数据用于服务器编译的第二层（C2编译器），以优化的方式编译该代码。默认情况下，Java 7中未启用分层编译，但在Java 8中启用了分层编译。实时（JIT）编译器将编译的代码存储在称为代码缓存的区域中。它是一个保存已编译代码的特殊堆。如果该区域的大小超过阈值，则该区域将被刷新，并且GC不会重新定位这些对象。Java 8中已经解决了一些性能问题和编译器未重新启用的问题，并且在Java 7中避免这些问题的解决方案之一是将代码缓存的大小增加到一个永远不会达到的程度。</p><ul><li>方法区</li></ul><p>方法区域是Perm Gen中空间的一部分，用于存储类结构（运行时常量和静态变量）以及方法和构造函数的代码。</p><ul><li>内存池</li></ul><p>内存池由JVM内存管理器创建，用于创建不可变对象池。内存池可以属于Heap或Perm Gen，具体取决于JVM内存管理器实现。</p><ul><li>常量池</li></ul><p>常量包含类运行时常量和静态方法，常量池是方法区域的一部分。</p><ul><li>Java堆栈内存</li></ul><p>Java堆栈内存用于执行线程。它们包含特定于方法的特定值，以及对从该方法引用的堆中其他对象的引用。</p><ul><li>Java堆内存配置项</li></ul><p>Java提供了许多内存配置项，我们可以使用它们来设置内存大小及其比例，常用的如下：</p><table><thead><tr><th>VM Switch</th><th>描述</th></tr></thead><tbody><tr><td>-Xms</td><td>用于在JVM启动时设置初始堆大小</td></tr><tr><td>-Xmx</td><td>用于设置最大堆大小</td></tr><tr><td>-Xmn</td><td>设置新生区的大小，剩下的空间用于老年区</td></tr><tr><td>-XX：PermGen</td><td>用于设置永久区存初始大小</td></tr><tr><td>-XX：MaxPermGen</td><td>用于设置Perm Gen的最大尺寸</td></tr><tr><td>-XX：SurvivorRatio</td><td>提供Eden区域的比例</td></tr><tr><td>-XX：NewRatio</td><td>用于提供老年代/新生代大小的比例，默认值为2</td></tr></tbody></table><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><h3 id="垃圾回收策略"><a href="#垃圾回收策略" class="headerlink" title="垃圾回收策略"></a>垃圾回收策略</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>References:</p><ul><li><a href="https://mp.weixin.qq.com/s/3_DEPdZTnGmdGBd5iTrVjQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3_DEPdZTnGmdGBd5iTrVjQ</a></li><li><a href="https://www.cnblogs.com/manayi/p/9290490.html" target="_blank" rel="noopener">https://www.cnblogs.com/manayi/p/9290490.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac平台搭建Golang环境</title>
      <link href="/2019/08/08/Mac%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BAGolang%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/08/08/Mac%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BAGolang%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/08/08/Mac平台搭建Golang环境/golang.png" alt></p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>我大概是在两年前开始接触Golang语言，当时我们公司在北美成立研发中心，核心成员都是来自Google、微软等世界一流互联网公司。那时起我们才真正有了CTO这个职位。他来自Google，所以把Google的核心开发语言Golang带到我们公司并大力推广。要求全员学习Golang。</p><p>当时业务部门的同事都比较抵触学习Golang，包括我在内。大家都把Java语言当作了吃饭的饭碗，认为Golang是一门比较难的语言，不情愿在这个上面花时间。后来事实证明当初的想法是错误的，其实Golang入门还是很容易的，包括搭建环境，相比较Java而言，要容易的多。</p><p>听我啰嗦了这么多，大家可不要认为Golang就是万能的。任何一门语言都有其优点和缺点，Golang也不例外。</p><blockquote><p><strong>优点</strong></p></blockquote><ul><li>Golang语法简单，可读性非常高，入门容易</li><li>基于 goroutines 和 channels 的简单并发编程</li><li>丰富的标准库</li><li>Golang性能优越</li><li>语言层面定义源代码的格式化</li><li>标准化的测试框架</li><li>Golang程序编译快，方便操作</li><li>Defer声明，避免忘记清理</li><li>方法多返回值：定义function可以返回多个值</li></ul><blockquote><p><strong>缺点</strong></p></blockquote><ul><li>Golang忽略了现代语言的进步</li><li>接口是结构类型</li><li>没有枚举</li><li>:= / var 两难选择</li></ul><p>说了这么多，让我们开始动手吧，本篇内容只会介绍如何搭建Golang开发环境</p><h1 id="Mac搭建Golang开发环境"><a href="#Mac搭建Golang开发环境" class="headerlink" title="Mac搭建Golang开发环境"></a>Mac搭建Golang开发环境</h1><p>介绍两种方式安装Golang环境</p><h2 id="通过HomeBrew安装"><a href="#通过HomeBrew安装" class="headerlink" title="通过HomeBrew安装"></a>通过HomeBrew安装</h2><p>Homebrew有点类似于Linux操作系统中的apt-get（Ubuntu）、yum（yum），Mac的操作系统中使用它解决包依赖问题，套用官方的话来说：使用 Homebrew 安装 Apple 没有预装但 你需要的东西。</p><h3 id="安装homebrew，已有则跳过"><a href="#安装homebrew，已有则跳过" class="headerlink" title="安装homebrew，已有则跳过"></a>安装homebrew，已有则跳过</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fabric:~ fabric$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>安装成功则提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Installation successful!</span><br><span class="line"></span><br><span class="line">==&gt; Homebrew has enabled anonymous aggregate user behaviour analytics.</span><br><span class="line">Read the analytics documentation (and how to opt-out) here:</span><br><span class="line">  https://docs.brew.sh/Analytics.html</span><br><span class="line"></span><br><span class="line">==&gt; Next steps:</span><br><span class="line">- Run `brew help` to get started</span><br><span class="line">- Further documentation: </span><br><span class="line">    https://docs.brew.sh</span><br></pre></td></tr></table></figure><h4 id="安装Golang"><a href="#安装Golang" class="headerlink" title="安装Golang"></a>安装Golang</h4><ul><li>首先看看有哪些Golang版本可用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chenbindeMacBook-Pro:BazelWorkspace chenbin$ brew search go</span><br><span class="line">==&gt; Formulae</span><br><span class="line">algol68g                      gnu-go                        gocr                          google-authenticator-libpam   gosu                          lgogdownloader                percona-server-mongodb</span><br><span class="line">anycable-go                   go                            gocryptfs                     google-benchmark              gotags                        libgosu                       protoc-gen-go</span><br><span class="line">arangodb                      go-bindata                    godep                         google-java-format            goto                          mongo-c-driver                pygobject</span><br><span class="line">argon2                        go-jira                       goenv                         google-sparsehash             gource                        mongo-cxx-driver              pygobject3</span><br><span class="line">aws-google-auth               go-statik                     gofabric8                     google-sql-tool               govendor                      mongo-orchestration           ringojs</span><br><span class="line">bogofilter                    go@1.10                       goffice                       googler                       gowsdl                        mongodb                       spaceinvaders-go</span><br><span class="line">cargo-completion              go@1.11                       golang-migrate                goolabs                       gox                           mongodb@3.0                   spigot</span><br><span class="line">certigo                       go@1.9                        gollum                        goose                         gst-plugins-good              mongodb@3.2                   svgo</span><br><span class="line">cgoban                        goaccess                      golo                          gopass                        gx-go                         mongodb@3.4                   wego</span><br><span class="line">clingo                        goad                          gom                           gor                           hugo                          mongodb@3.6                   wireguard-go</span><br><span class="line">django-completion             gobby                         gomplate                      goreleaser                    jfrog-cli-go                  mongoose                      write-good</span><br><span class="line">forego                        gobject-introspection         goocanvas                     goreman                       jpegoptim                     pango</span><br><span class="line">fuego                         gobuster                      goofys                        gost                          lego                          pangomm</span><br></pre></td></tr></table></figure><p>我们发现最新的有1.11可以使用</p><ul><li>安装brew下最新版本的Golang</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fabric:~ fabric$ brew install go@1.11</span><br></pre></td></tr></table></figure><ul><li>配置Golang的环境变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chenbindeMacBook-Pro:BazelWorkspace chenbin$ vi /Users/chenbin/.bash_profile</span><br></pre></td></tr></table></figure><blockquote><p><strong>NOTE:</strong> 在Linux环境下是 <strong>vim ~/.bashrc</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/Volumes/BazelWorkspace/bazel-go</span><br><span class="line"></span><br><span class="line">export PATH=$GOROOT/bin:$GOPATH/bin:$PATH</span><br></pre></td></tr></table></figure><blockquote><p><strong>NOTE:</strong> GOPATH可以根据个人习惯设置为其他目录</p></blockquote><p>让改动生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chenbindeMacBook-Pro:BazelWorkspace chenbin$ source ~/.bash_profile</span><br></pre></td></tr></table></figure><ul><li>试一试Golang是否安装成功</li></ul><p>出现以下内容，则安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">chenbindeMacBook-Pro:BazelWorkspace chenbin$ go env</span><br><span class="line">GOARCH=&quot;amd64&quot;</span><br><span class="line">GOBIN=&quot;&quot;</span><br><span class="line">GOCACHE=&quot;/Users/chenbin/Library/Caches/go-build&quot;</span><br><span class="line">GOEXE=&quot;&quot;</span><br><span class="line">GOFLAGS=&quot;&quot;</span><br><span class="line">GOHOSTARCH=&quot;amd64&quot;</span><br><span class="line">GOHOSTOS=&quot;darwin&quot;</span><br><span class="line">GOOS=&quot;darwin&quot;</span><br><span class="line">GOPATH=&quot;/Volumes/BazelWorkspace/bazel-go&quot;</span><br><span class="line">GOPROXY=&quot;&quot;</span><br><span class="line">GORACE=&quot;&quot;</span><br><span class="line">GOROOT=&quot;/usr/local/go&quot;</span><br><span class="line">GOTMPDIR=&quot;&quot;</span><br><span class="line">GOTOOLDIR=&quot;/usr/local/go/pkg/tool/darwin_amd64&quot;</span><br><span class="line">GCCGO=&quot;gccgo&quot;</span><br><span class="line">CC=&quot;clang&quot;</span><br><span class="line">CXX=&quot;clang++&quot;</span><br><span class="line">CGO_ENABLED=&quot;1&quot;</span><br><span class="line">GOMOD=&quot;&quot;</span><br><span class="line">CGO_CFLAGS=&quot;-g -O2&quot;</span><br><span class="line">CGO_CPPFLAGS=&quot;&quot;</span><br><span class="line">CGO_CXXFLAGS=&quot;-g -O2&quot;</span><br><span class="line">CGO_FFLAGS=&quot;-g -O2&quot;</span><br><span class="line">CGO_LDFLAGS=&quot;-g -O2&quot;</span><br><span class="line">PKG_CONFIG=&quot;pkg-config&quot;</span><br><span class="line">GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/hw/12mwhf310xd8m8k3bhtjxqp00000gn/T/go-build698784611=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;</span><br></pre></td></tr></table></figure><h2 id="直接下载Golang包"><a href="#直接下载Golang包" class="headerlink" title="直接下载Golang包"></a>直接下载Golang包</h2><ul><li>直接在github下载源程序包</li></ul><p><strong>根据自己的需求下载适当的版本，推荐选择当下最新版本</strong></p><p>下载地址： <a href="https://github.com/golang/go/releases" target="_blank" rel="noopener">https://github.com/golang/go/releases</a></p><ul><li><p>解压到你想配置的GOROOT目录</p></li><li><p>配置Golang环境变量（与通过Homebrew安装Golang的配置方式一样)</p></li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>我个人推荐通过直接下载源程序包的方式安装，不仅省去了安装Homebrew的步骤，而且耗时更短。</p><p>我们开发golang的code一般放在 <strong>$GOPATH/src</strong> 目录下，下一章我会教大家如何利用工具简单而且方便的开发Golang</p><blockquote><p><strong>NOTE:</strong> 提前剧透一下，大家可以先看看 <a href="https://github.com/linuxerwang/gobazel" target="_blank" rel="noopener">https://github.com/linuxerwang/gobazel</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件常用命令</title>
      <link href="/2019/08/02/Linux%20%E6%96%87%E4%BB%B6%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/08/02/Linux%20%E6%96%87%E4%BB%B6%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux文件常用命令"><a href="#Linux文件常用命令" class="headerlink" title="Linux文件常用命令"></a>Linux文件常用命令</h1><h2 id="文件解压缩"><a href="#文件解压缩" class="headerlink" title="文件解压缩"></a>文件解压缩</h2><blockquote><p>解压 .tar.gz 和 .tgz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf filename.tar.gz</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>压缩 .tar.gz 和 .tgz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zcvf filename.tar.gz</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>linux下tar命令解压到指定的目录：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#tar xvf /bbs.tar.zip -C /zzz/bbs</span><br></pre></td></tr></table></figure></p><blockquote><p>把根目录下的bbs.tar.zip解压到/zzz/bbs下，前提要保证存在/zzz/bbs这个目录<br>这个和cp命令有点不同，cp命令如果不存在这个目录就会自动创建这个目录！<br>附：用tar命令打包<br>例：将当前目录下的zzz文件打包到根目录下并命名为zzz.tar.gz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; #tar zcvf /zzz.tar.gz ./zzz</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>解压 .zip</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip filename.zip</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>压缩 .zip</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip filename.zip</span><br><span class="line">压缩一个目录使用 -r 参数， -r 递归。 例： $ zip -r filename.zip dirname</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>解压 .rar</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar x filename.rar</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>压缩 .rar</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar a filename.rar dirname</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><h3 id="最强大的搜索命令：find"><a href="#最强大的搜索命令：find" class="headerlink" title="最强大的搜索命令：find"></a>最强大的搜索命令：find</h3><p>find命令是我们在Linux系统中用来进行文件搜索用的最多的命令，功能特别强大。但是我们要说的是尽量少用find命令去执行搜索任务，就算要搜索我们也应该尽量的缩小范围，也不要在服务器使用高峰期进行文件搜索，因为搜索也是很占系统资源的。这就需要我们在进行Linux文件整理的时候，尽量规范化，什么文件放在什么目录下都要有比较好的约定。</p><h3 id="根据文件或目录名称搜索"><a href="#根据文件或目录名称搜索" class="headerlink" title="根据文件或目录名称搜索"></a>根据文件或目录名称搜索</h3><blockquote><p>find 【搜索目录】【-name或者-iname】【搜索字符】：-name和-iname的区别一个区分大小写，一个不区分大小写</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /etc -name init   (精准搜索，名字必须为 init 才能搜索的到)</span><br><span class="line">find /etc -iname init   (精准搜索，名字必须为 init或者有字母大写也能搜索的到)</span><br><span class="line">find /etc -name *init  (模糊搜索，以 init 结尾的文件或目录名) </span><br><span class="line">find /etc -name init??? (模糊搜索，？ 表示单个字符，即搜索到 init___)</span><br></pre></td></tr></table></figure><h3 id="根据-文件大小-搜索"><a href="#根据-文件大小-搜索" class="headerlink" title="根据 文件大小 搜索"></a>根据 文件大小 搜索</h3><p>比如：在根目录下查找大于 100M 的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -size +204800</span><br></pre></td></tr></table></figure><blockquote><p><strong>NOTE:</strong> 这里 +n 表示大于，-n 表示小于，n 表示等于1 数据块 == 512 字节 ==0.5KB，也就是1KB等于2数据块100MB == 102400KB==204800数据块</p></blockquote><h3 id="递归搜索并删除"><a href="#递归搜索并删除" class="headerlink" title="递归搜索并删除"></a>递归搜索并删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find /tmp/98/upload -name *.avi -type f -print -exec rm -rf &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">find . -name abc -type d -print -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure><blockquote><ol><li>“.”    表示从当前目录开始递归查找</li><li>“ -name ‘*.exe’ “根据名称来查找，要查找所有以.exe结尾的文件夹或者文件</li><li>“ -type f “查找的类型为文件</li><li>“-print” 输出查找的文件目录名</li><li>最主要的是是-exec了，-exec选项后边跟着一个所要执行的命令，表示将find出来的文件或目录执行该命令。exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个\，最后是一个分号</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot中application.properties与bootstrap.properties的区别</title>
      <link href="/2019/08/01/Spring%20Boot%E4%B8%ADapplication.properties%E4%B8%8Ebootstrap.properties%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/08/01/Spring%20Boot%E4%B8%ADapplication.properties%E4%B8%8Ebootstrap.properties%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="application-propertes-application-yml"><a href="#application-propertes-application-yml" class="headerlink" title="application.propertes (application.yml)"></a>application.propertes (application.yml)</h1><p>现在使用SpringBoot是Java世界里的主流选择，它大大简化了应用初始搭建以及开发过程，该框架使用了特定的方式来进行配置，从而是开发人员不在需要定义样板化的配置。今天就带大家来了解下application.properties</p><p>使用application.properties，一般情况下主要用来配置服务中一些最基本的属性，如 数据库连接、日志相关配置。其他的用法还有 一般属性使用、自定义属性使用、属性间的引用(占位符)、随机数的使用、数据类型自动转换、嵌套属性注入</p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active=dev,vexillary-service,skylb,file_server,kafka_monitor_0.8,metrics</span><br><span class="line"></span><br><span class="line">#gRPC</span><br><span class="line">grpc.port=6567</span><br><span class="line"></span><br><span class="line">#metrics</span><br><span class="line">metrics.scrapePort=10000</span><br><span class="line"></span><br><span class="line"># logging level</span><br><span class="line">logging.level.root=error</span><br><span class="line">logging.level.com.jingoal.grpc=debug</span><br><span class="line">logging.level.com.jingoal.approval=debug</span><br></pre></td></tr></table></figure></p><h2 id="application-properties与bootstrap-properties的区别"><a href="#application-properties与bootstrap-properties的区别" class="headerlink" title="application.properties与bootstrap.properties的区别"></a>application.properties与bootstrap.properties的区别</h2><p>两者主要区别是加载顺序不同，bootstrap.properties在application.properties 之前加载，bootstrap.properties用于应用程序上下文的引导阶段</p><h3 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h3><ol><li>当时用Spring Cloud Config Server的时候，你应该在bootstraop.properties里面指定spring.application.name 和 spring.cloud.config.server.git.uri</li><li>一些加密/解密的信息</li></ol><p>技术上, bootstrap.properties由父Spring ApplicationContext加载。父ApplicationContext 被加载到使用application.properties的之前。</p><p>当使用SpringCloud的时候，配置信息一般是从config server加载的，为了取得配置信息（比如密码等），你需要一些提早的或引导配置。因此，把config server信息放在bootstrap.properties，用来加载真正需要的配置信息。</p><h3 id="属性覆盖问题"><a href="#属性覆盖问题" class="headerlink" title="属性覆盖问题"></a>属性覆盖问题</h3><p>启动上下文时，<strong>Spring Cloud</strong>会创建一个<code>BootStrap Context</code>，作为Spring应用的<code>Application Context</code>的父上下文。初始化的时候，<code>Bootstrap Context</code>负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的<code>Environment</code>。</p><p><strong>Bootstrap属性有高优先级，默认情况下，他们不会被本地配置覆盖</strong>。<br><code>Bootstrap  Context</code>和<code>Application Context</code>有着不同的约定，所以新增了一个<code>bootstrap.properties</code>，而不是使用<code>application.properties</code>。保证<code>Bootstrap Context</code>和<code>Application Context</code>配置的分离。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化原理</title>
      <link href="/2019/07/29/MySQL%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/"/>
      <url>/2019/07/29/MySQL%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说起MySQL的查询优化，相信大家收藏了一堆奇技淫巧：不能使用SELECT *、不使用NULL字段、合理创建索引、为字段选择合适的数据类型….. 你是否真的理解这些优化技巧？是否理解其背后的工作原理？在实际场景下性能真有提升吗？我想未必。因而理解这些优化建议背后的原理就尤为重要，希望本文能让你重新审视这些优化建议，并在实际业务场景下合理的运用。</p><h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><p>如果能在头脑中构建一幅MySQL各组件之间如何协同工作的架构图，有助于深入理解MySQL服务器。下图展示了MySQL的逻辑架构图。</p><p><img src="/2019/07/29/MySQL优化原理/MySQL.png" alt="MySQL逻辑架构，来自：高性能MySQL"></p><p>MySQL逻辑架构整体分为三层，最上层为客户端层，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。</p><p>MySQL大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。</p><p>最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。</p><h2 id="MySQL查询过程"><a href="#MySQL查询过程" class="headerlink" title="MySQL查询过程"></a>MySQL查询过程</h2><p>我们总是希望MySQL能够获得更高的查询性能，最好的办法是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，就会发现：<strong>很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。</strong></p><p>当向MySQL发送一个请求的时候，MySQL到底做了些什么呢？</p><p><img src="/2019/07/29/MySQL优化原理/MySQL-Process.png" alt="MySQL查询过程"></p><h3 id="客户端-服务端通信协议"><a href="#客户端-服务端通信协议" class="headerlink" title="客户端/服务端通信协议"></a>客户端/服务端通信协议</h3><p>MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。</p><p>客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置<code>max_allowed_packet</code>参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p><p>与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用<code>SELECT *</code>以及加上<code>LIMIT</code>限制的原因之一。</p><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>在解析一个查询语句前，如果查询缓存是打开的，那么MySQL会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p><p>MySQL将缓存存放在一个引用表（不要理解成<code>table</code>，可以认为是类似于<code>HashMap</code>的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</p><p>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql库中的系统表，其查询结果<br>都不会被缓存。比如函数<code>NOW()</code>或者<code>CURRENT_DATE()</code>会因为不同的查询时间，返回不同的查询结果，再比如包含<code>CURRENT_USER</code>或者<code>CONNECION_ID()</code>的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。</p><p>既然是缓存，就会失效，那查询缓存何时失效呢？MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿。而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外：</p><ol><li>任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存</li><li>如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗</li></ol><p>基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。但要如何评估打开缓存是否能够带来性能提升是一件非常困难的事情，也不在本文讨论的范畴内。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如：</p><ol><li>用多个小表代替一个大表，注意不要过度设计</li><li>批量插入代替循环单条插入</li><li>合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适</li><li>可以通过<code>SQL_CACHE</code>和<code>SQL_NO_CACHE</code>来控制某个查询语句是否需要进行缓存</li></ol><p>最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将<code>query_cache_type</code>设置为<code>DEMAND</code>，这时只有加入<code>SQL_CACHE</code>的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux查看系统硬件信息</title>
      <link href="/2019/07/29/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/"/>
      <url>/2019/07/29/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux查看系统硬件信息"><a href="#Linux查看系统硬件信息" class="headerlink" title="Linux查看系统硬件信息"></a>Linux查看系统硬件信息</h1><h2 id="查看当前操作系统内核信息"><a href="#查看当前操作系统内核信息" class="headerlink" title="查看当前操作系统内核信息"></a>查看当前操作系统内核信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chenbin@chenbin-ThinkPad:~$ uname -a</span><br><span class="line">Linux chenbin-ThinkPad 4.15.0-36-generic #39-Ubuntu SMP Mon Sep 24 16:19:09 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><h2 id="查看当前操作系统发行版信息"><a href="#查看当前操作系统发行版信息" class="headerlink" title="查看当前操作系统发行版信息"></a>查看当前操作系统发行版信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chenbin@chenbin-ThinkPad:~$ cat /etc/issue</span><br><span class="line">Ubuntu 18.04.1 LTS \n \l</span><br></pre></td></tr></table></figure><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="CPU详细信息"><a href="#CPU详细信息" class="headerlink" title="CPU详细信息"></a>CPU详细信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@mini-11:~$ lscpu</span><br><span class="line">Architecture:        x86_64</span><br><span class="line">CPU op-mode(s):      32-bit, 64-bit         #CPU 运行模式</span><br><span class="line">Byte Order:          Little Endian          #字节序</span><br><span class="line">CPU(s):              4                      #CPU个数</span><br><span class="line">On-line CPU(s) list: 0-3                    #在线 CPU 列表</span><br><span class="line">Thread(s) per core:  2                      #每个核的线程数</span><br><span class="line">Core(s) per socket:  2                      #每个cpu插槽核数/每颗物理cpu核数</span><br><span class="line">Socket(s):           1                      #CPU插槽数</span><br><span class="line">NUMA node(s):        1                      #NUMA 节点</span><br><span class="line">Vendor ID:           GenuineIntel           #厂商 ID</span><br><span class="line">CPU family:          6                      #CPU系列</span><br><span class="line">Model:               69                     #型号</span><br><span class="line">Model name:          Intel(R) Core(TM) i7-4600U CPU @ 2.10GHz</span><br><span class="line">Stepping:            1</span><br><span class="line">CPU MHz:             2290.247               #CPU MHz</span><br><span class="line">CPU max MHz:         3300.0000              #CPU 最大 MHz</span><br><span class="line">CPU min MHz:         800.0000               #CPU 最小 MHz</span><br><span class="line">BogoMIPS:            5387.11</span><br><span class="line">Virtualization:      VT-x</span><br><span class="line">L1d cache:           32K                #一级缓存32K（google了下，这具体表示表示cpu的L1数据缓存为32k）</span><br><span class="line">L1i cache:           32K                #一级缓存32K（具体为L1指令缓存为32K）</span><br><span class="line">L2 cache:            256K               #二级缓存256K</span><br><span class="line">L3 cache:            4096K              #三级缓存4096K</span><br><span class="line">NUMA node0 CPU(s):   0-3</span><br><span class="line">Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm abm cpuid_fault epb invpcid_single pti tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid xsaveopt dtherm ida arat pln pts</span><br></pre></td></tr></table></figure><blockquote><p>NOTE: 查看<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 查看物理CPU个数</span><br></pre></td></tr></table></figure></p></blockquote><p>[root@DB-Server ~]# cat /proc/cpuinfo | grep “physical id” | sort | uniq | wc -l</p><p>[root@DB-Server ~]# dmesg | grep CPU | grep “Physical Processor ID” | uniq | wc -l<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 查看逻辑CPU个数</span><br></pre></td></tr></table></figure></p><p>[root@DB-Server ~]# cat /proc/cpuinfo | grep “processor” | wc -l</p><p>[root@DB-Server ~]# dmesg | grep “CPU” | grep “processor” | wc -l<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 查看CPU是几核的</span><br></pre></td></tr></table></figure></p><p>[root@DB-Server ~]# cat /proc/cpuinfo | grep “cores” | uniq</p><p>cpu cores : 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 查看CPU的主频</span><br></pre></td></tr></table></figure></p><p>[root@DB-Server ~]# cat /proc/cpuinfo | grep MHz | uniq<br>cpu MHz : 800.000</p><p>[root@DB-Server ~]# cat /proc/cpuinfo | grep MHz<br>cpu MHz : 800.000<br>cpu MHz : 800.000<br>cpu MHz : 800.000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 查看CPU型号信息</span><br></pre></td></tr></table></figure></p><p>[root@DB-Server ~]# cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</p><p>3 AMD Athlon(tm) II X3 450 Processor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 通过physical id 可以判断物理CPU个数</span><br></pre></td></tr></table></figure></p><p>[root@DB-Server ~]# cat /proc/cpuinfo | grep physical | uniq -c<br>physical id : 0<br>address sizes : 48 bits physical, 48 bits virtual<br>physical id : 0<br>address sizes : 48 bits physical, 48 bits virtual<br>physical id : 0<br>address sizes : 48 bits physical, 48 bits virtual<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 查看CPU是否支持64位运算</span><br></pre></td></tr></table></figure></p><p>[root@DB-Server ~]# cat /proc/cpuinfo | grep flags | grep ‘lm’ | wc -l<br>3</p><p>结果大于0，说明支持64位运算，lm指long mode 支持lm则是64bit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">[root@DB-Server ~]# getconf LONG_BIT</span><br><span class="line">etl:/home/etl/$getconf LONG_BIT（另外一台服务器）</span><br><span class="line"></span><br><span class="line">说明当前CPU运行在32位模式下，当不代表CPU不支持64位</span><br></pre></td></tr></table></figure></p><h2 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@DB-Server ~]# more /proc/meminfo</span><br><span class="line">MemTotal:        7541288 kB</span><br><span class="line">MemFree:          215388 kB</span><br><span class="line">Buffers:          186228 kB</span><br><span class="line">Cached:          6433572 kB</span><br><span class="line">SwapCached:        77404 kB</span><br><span class="line">Active:          5489928 kB</span><br><span class="line">Inactive:        1346252 kB</span><br><span class="line">Active(anon):    5193596 kB</span><br><span class="line">Inactive(anon):  1015024 kB</span><br><span class="line">Active(file):     296332 kB</span><br><span class="line">Inactive(file):   331228 kB</span><br><span class="line">Unevictable:           0 kB</span><br><span class="line">Mlocked:               0 kB</span><br><span class="line">SwapTotal:       9781240 kB</span><br><span class="line">SwapFree:        9430432 kB</span><br><span class="line">Dirty:                 0 kB</span><br><span class="line">Writeback:             0 kB</span><br><span class="line">AnonPages:        139432 kB</span><br><span class="line">Mapped:          3878064 kB</span><br><span class="line">Shmem:           5992240 kB</span><br><span class="line">Slab:             328284 kB</span><br><span class="line">SReclaimable:     159572 kB</span><br><span class="line">SUnreclaim:       168712 kB</span><br><span class="line">KernelStack:        2056 kB</span><br><span class="line">PageTables:        99256 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:    13551884 kB</span><br><span class="line">Committed_AS:    6943792 kB</span><br><span class="line">VmallocTotal:   34359738367 kB</span><br><span class="line">VmallocUsed:      301620 kB</span><br><span class="line">VmallocChunk:   34359431420 kB</span><br><span class="line">HardwareCorrupted:     0 kB</span><br><span class="line">AnonHugePages:     30720 kB</span><br><span class="line">HugePages_Total:       0</span><br><span class="line">HugePages_Free:        0</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br><span class="line">DirectMap4k:        8128 kB</span><br><span class="line">DirectMap2M:     2611200 kB</span><br><span class="line">DirectMap1G:     5242880 kB</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Systerm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC框架</title>
      <link href="/2019/07/21/RPC%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/07/21/RPC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大概是三年前我开始接触RPC，那时作为一个刚入职场三年的新兵，在公司技术架构决策层上还没有什么发言权。一直沿用前辈搭建的技术架构来开发应用系统，当时还没有前后端分离，采用的框架是<code>Spring MVC + JSP</code>，每个应用服务都是一个war，服务间的调用是通过共享访问数据库的代码包(jar)来实现，现在想想那时的技术是真的Low，导致现在欠了很多的技术债，直到现在我们也还在努力的还债。</p><p>后来随着服务不断增加，而且服务之前还需要互相调用，这种方式导致维护的成本越来越高。这时领导才下定决心要重构技术架构，要引入微服务并进行前后端分离，这才拉开了服务化的进程，从那时起我们开始引入RPC框架。</p><p>本片文章我会带领大家来了解这几个方面的内容：什么是RPC，为什么要使用RPC以及常见的RPC框架。</p><h1 id="RPC简介"><a href="#RPC简介" class="headerlink" title="RPC简介"></a>RPC简介</h1><p>RPC 是远程过程调用（Remote Procedure Call）的缩写形式，Birrell 和 Nelson 在 1984 发表于 ACM Transactions on Computer Systems 的论文<strong>《Implementing remote procedure calls》</strong>对 RPC 做了经典的诠释。RPC 是指计算机 A 上的进程，调用另外一台计算机 B 上的进程，其中 A 上的调用进程被挂起，而 B 上的被调用进程开始执行，当值返回给 A 时，A 进程继续执行。调用方可以通过使用参数将信息传送给被调用方，而后可以通过传回的结果得到信息。而这一过程，对于开发人员来说是透明的。<br><img src="/2019/07/21/RPC框架/what-rpc.png" alt="image"><br>上图描述了数据报在一个简单的RPC传递的过程</p><p>当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。<br><img src="/2019/07/21/RPC框架/what-rpc1.png" alt="image"></p><p>其中 RPC 和 HTTP 调用是没有经过中间件的，它们是端到端系统的直接数据交互。HTTP 调用其实也可以看成是一种特殊的 RPC，只不过传统意义上的 RPC 是指长连接数据交互，而 HTTP 一般是指即用即走的短链接。</p><p>RPC 在我们熟知的各种中间件中都有它的身影。Nginx/Redis/MySQL/Dubbo/Hadoop/Spark/Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的，我们这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术。RPC 在技术中的地位好比我们身边的空气，它无处不在，但是又有很多人根本不知道它的存在。</p><h1 id="为什么要使用RPC"><a href="#为什么要使用RPC" class="headerlink" title="为什么要使用RPC"></a>为什么要使用RPC</h1><ol><li>首先要明确一点：RPC可以用HTTP协议实现，并且用HTTP是建立在TCP之上最广泛使用的RPC，但是互联网公司往往用自己的私有协议，比如鹅厂的JCE协议，私有协议不具备通用性为什么还要用呢？因为相比于HTTP协议，RPC采用二进制字节码传输，更加高效也更加安全。</li><li>现在业界提倡“微服务”的概念，而服务之间通信目前有两种方式，RPC就是其中一种。RPC可以保证不同服务之间的互相调用。即使是跨语言跨平台也不是问题，让构建分布式系统更加容易。</li><li>RPC框架都会有服务降级，流程控制的功能，保证服务的高可用。</li></ol><h1 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h1><p>要想了解一个RPC框架是如何实现的，首先要明白以下几点：</p><blockquote><p><strong>Call ID映射</strong></p></blockquote><p>我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 <--> Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</--></p><blockquote><p><strong>序列化和反序列化</strong></p></blockquote><p>客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</p><blockquote><p><strong>网络传输</strong></p></blockquote><p>远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西</p><h2 id="常用的RPC框架"><a href="#常用的RPC框架" class="headerlink" title="常用的RPC框架"></a>常用的RPC框架</h2><p>常用的RPC框架在语言上支持Java的最多，golang次之</p><ol><li>Netty - Netty框架不局限于RPC，更多的是作为一种网络协议的实现框架，比如HTTP，由于RPC需要高效的网络通信，就可能选择以Netty作为基础。</li><li>brpc是一个基于protobuf接口的RPC框架，在百度内部称为“baidu-rpc”，它囊括了百度内部所有RPC协议，并支持多种第三方协议，从目前的性能测试数据来看，brpc的性能领跑于其他同类RPC产品。</li><li>Dubbo是Alibaba开发的一个RPC框架，远程接口基于Java Interface, 依托于Spring框架。</li><li>gRPC的Java实现的底层网络库是基于Netty开发而来，其Go实现是基于net库。</li><li>Thrift是Apache的一个项目(<a href="http://thrift.apache.org)，前身是Facebook开发的一个RPC框架，采用thrift作为IDL" target="_blank" rel="noopener">http://thrift.apache.org)，前身是Facebook开发的一个RPC框架，采用thrift作为IDL</a> (Interface description language)。</li><li>jsonrpc</li></ol><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>后面我会继续发文深入介绍gRPC框架和在工作中是如何应用gRPC框架的</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中 乐观锁、悲观锁、共享锁、排它锁、行锁、表锁的理解</title>
      <link href="/2019/01/20/MySQL%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2019/01/20/MySQL%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/20/MySQL锁的理解/MySQL.jpeg" alt="MySQL"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL/InnoDB的加锁，一直是一个面试中常见的话题。例如，数据库如果有高并发请求，如果保证数据完整性？产生死锁问题如何排查并解决？我在工作过程中，也会经常用到，乐观锁，排它锁 等。最近针对这几个概念进行学习，记录一下。</p><blockquote><p>注: MySQL是一个支持插件式存储引擎的数据库系统。本文下面的所有介绍，都是基于InnoDB存储引擎，其他引擎的表现，会有较大的区别。</p></blockquote><h2 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h2><p>MySQL给开发者提供了查询存储引擎的功能，我这里使用的是MySQL5.6.4，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINES</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/MySQL锁的理解/Engines.jpeg" alt="engines"></p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>用数据版本(Version)记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库增加一个数字类型的“version”字段来实现。当读数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次读取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ol><li>数据库表设计</li></ol><p>三个字段，分别是id、value、version</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,value,version from TABLE where id=#&#123;id&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>每次更新表中的value字段时，为了防止发生冲突，需要这样操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update TABLE</span><br><span class="line">set value=2,version=version+1</span><br><span class="line">where id=#&#123;id&#125; and version=#&#123;version&#125;;</span><br></pre></td></tr></table></figure><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</p><p>说到这里，由悲观锁涉及到的另外两个概念就出来了，他们就是共享锁与排它锁。<strong>共享锁和排它锁是悲观锁的不同实现</strong>，它俩都属于悲观锁的范畴。</p><p>使用排它锁举例：</p><p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作时，MySQL会立刻将结果进行提交。</p><p>我们可以使用命令设置MySQL为非autocommit模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0;</span><br><span class="line"></span><br><span class="line"># 设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：</span><br><span class="line"></span><br><span class="line"># 1. 开始事务</span><br><span class="line"></span><br><span class="line">begin;/begin work;/start transaction; (三者选一就可以)</span><br><span class="line"></span><br><span class="line"># 2. 查询表信息</span><br><span class="line"></span><br><span class="line">select status from TABLE where id=1 for update;</span><br><span class="line"></span><br><span class="line"># 3. 插入一条数据</span><br><span class="line"></span><br><span class="line">insert into TABLE (id,value) values (2,2);</span><br><span class="line"></span><br><span class="line"># 4. 修改数据为</span><br><span class="line"></span><br><span class="line">update TABLE set value=2 where id=1;</span><br><span class="line"></span><br><span class="line"># 5. 提交事务</span><br><span class="line"></span><br><span class="line">commit;/commit work;</span><br></pre></td></tr></table></figure><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁又称<strong>读锁 read lock</strong>，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。</p><p>如果事务T对数据A加上共享锁后，则其他事务只能对数据A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据</p><h2 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h2><p>排他锁 exclusive lock（也叫writer lock）又称<strong>写锁</strong>。</p><p>排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。</p><p>若事务 1 对数据对象A加上X锁，事务 1 可以读A也可以修改A，其他事务不能再对A加任何锁，直到事物 1 释放A上的锁。这保证了其他事务在事物 1 释放A上的锁之前不能再读取和修改A。排它锁会阻塞所有的排它锁和共享锁</p><p>读取为什么要加读锁呢：防止数据在被读取的时候被别的线程加上写锁，</p><p>使用方式：在需要执行的语句后面加上for update就可以了</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>行锁又分<strong>共享锁</strong>和<strong>排他锁</strong>,由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。</p><blockquote><p>NOTE: 行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。</p></blockquote><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>如何加表锁</p><p>innodb 的行锁是在有索引的情况下,没有索引的表是锁定全表的.</p><p><strong>Innodb中的行锁与表锁</strong></p><p>前面提到过，在Innodb引擎中既支持行锁也支持表锁，那么什么时候会锁住整张表，什么时候或只锁住一行呢？<br>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p><p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><p>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁（Deadlock） </p><p>所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。</p><h3 id="下列方法有助于最大限度地降低死锁："><a href="#下列方法有助于最大限度地降低死锁：" class="headerlink" title="下列方法有助于最大限度地降低死锁："></a>下列方法有助于最大限度地降低死锁：</h3><ol><li>按同一顺序访问对象。</li><li>避免事务中的用户交互。</li><li>保持事务简短并在一个批处理中。</li><li>使用低隔离级别。</li><li>使用绑定连接。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何查看MariaDB bin log</title>
      <link href="/2018/09/04/%E6%9F%A5%E7%9C%8BMariaDB-binlog/"/>
      <url>/2018/09/04/%E6%9F%A5%E7%9C%8BMariaDB-binlog/</url>
      
        <content type="html"><![CDATA[<h2 id="MariaDB-bin-log"><a href="#MariaDB-bin-log" class="headerlink" title="MariaDB bin log"></a>MariaDB bin log</h2><p>今天在学习MariaDB在产线的部署架构时，重新了解了主从复制的原理，同时产生想查看bin log的好奇心，折腾了一番最终搞定</p><h2 id="MariaDB主从复制"><a href="#MariaDB主从复制" class="headerlink" title="MariaDB主从复制"></a>MariaDB主从复制</h2><p><img src="/2018/09/04/查看MariaDB-binlog/mariadb-binlog.png" alt="image"></p><p><strong>MySQL的复制就是基于二进制日志而完成的，其工作原理如下：</strong></p><blockquote><p>当MySQL的Master节点的数据有更改的时候，Master会主动通知Slave，让Slave主动来Master获取二进制日志，于是Slave开启一个I/O thread，向Master请求二进制日志中记录的语句；Master将二进制日志中记录的语句发给Slave，Slave则将这些语句存到中继日志中，进而从中继日志中读取一句，执行一句，直到所有的语句被执行完。而经SQL语句从中继日志中读取出来，再一一执行的进程叫做SQL thread；将这些语句执行完之后，从节点的数据就和主节点的数据相同了，这就是所谓的MySQL主从复制。</p></blockquote><h2 id="查看bin-log"><a href="#查看bin-log" class="headerlink" title="查看bin log"></a>查看bin log</h2><p><strong>在我们的一个测试环境上，通过如下命令查看</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show binary logs;</span><br><span class="line">1381 - You are not using binary logging</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show variables like &apos;log_bin&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_bin | OFF |</span><br><span class="line">+---------------+-------+</span><br><span class="line"></span><br><span class="line">错误原因：测试环境中部署的实例没有开启bin log</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; set global log_bin_trust_function_creators=1;</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show variables like &apos;log_bin_trust_function_creators&apos;;</span><br><span class="line"></span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">| log_bin_trust_function_creators | ON |</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line"></span><br><span class="line">这样添加了参数以后，如果mysqld重启，那个参数又会消失，因此记得在my.cnf配置文件中添加：</span><br><span class="line"></span><br><span class="line">log_bin_trust_function_creators=1</span><br><span class="line"></span><br><span class="line">log_bin=mysql_bin</span><br><span class="line"></span><br><span class="line">添加参数之后重启mysql</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show binary logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql_bin.000001 | 217795 |</span><br><span class="line">+------------------+-----------+</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@mariadb bin]# mysqlbinlog –no-defaults mysql-bin.00001;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;</span><br><span class="line">/*!40019 SET @@session.max_insert_delayed_threads=0*/;</span><br><span class="line">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;</span><br><span class="line"></span><br><span class="line">DELIMITER /*!*/;</span><br><span class="line">mysqlbinlog: File &apos;&apos; not found (Errcode: 2)</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># End of log file</span><br><span class="line">ROLLBACK /* added by mysqlbinlog */;</span><br><span class="line"></span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br></pre></td></tr></table></figure><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>从上面Mariadb复制原理中我认为bin log记录的master上执行的sql语句，但是为什么bin log看不到呢？</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MariaDB </tag>
            
            <tag> binlog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用正则引发的血案</title>
      <link href="/2018/09/01/%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/"/>
      <url>/2018/09/01/%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式, 一个十分古老而又强大的文本处理工具, 仅仅用一段非常简短的表达式语句, 便能够快速实现一个非常复杂的业务逻辑. 熟练地掌握正则表达式的话, 能够使你的开发效率得到极大的提升.</p><p>对于一些简单的表单式语句我们可以自己编写, 但是复杂一些并且通用的表达式我们往往会从网上直接拷贝来用. 经过大部分人实践过的一般不会出现问题, 但是偶尔也会踩坑. 最近我就在这个上面掉进了深坑.</p><h2 id="案发"><a href="#案发" class="headerlink" title="案发"></a>案发</h2><p>最近产线上的一个服务连续两天出现问题, 现象就是访问出现 “502 Bad Gateway” 错误. 这个服务是部署在Tomcat下的, 字面上理解就是网关出现问题了, 第一次出现问题后为了紧急修复就直接重启了服务器, 重启后就正常了. 这次事故就这样草草收场，没有留下任何有用的日志信息用来分析, 就没有继续追查下去了.</p><p>偷懒是会受到惩罚的. 果不其然, 第二天问题继续出现, 并且还引起了其他的故障. 有了前车之鉴, 这一次受到了足够重视. 为了尽快恢复服务, 重启了部分节点用来恢复产线服务. 留了一个故障节点来断案.</p><h2 id="断案"><a href="#断案" class="headerlink" title="断案"></a>断案</h2><h3 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h3><ol><li>系统本身代码有问题, 如果是这样, 通过查看日志应该能发现集中的日志. 但是却没有, <strong>初步排除代码逻辑处理错误</strong></li><li>内部下游系统的问题导致的雪崩效应, 我们联系了内部下游系统观察了他们的监控，发现一起正常。<strong>可以排除下游系统故障对我们的影响</strong></li><li>机器本身的问题, 查看机器监控, 排除机器故障问题。</li></ol><p><strong>即通过上述方法没有直接定位到问题。</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>之前为了快速恢复服务, 我们留下了一个故障节点, 从产线上摘除, 重启了其他节点恢复服务.</p><p>下面通过jstack来分析故障</p><ol><li><p>查看当前Tomcat线程pid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx ~]# ps -ef | grep tomcat</span><br><span class="line">root       142     1  0 Aug20 ?        02:46:26 /usr/local/jdk/jre/bin/java -Djava.util.logging.config.file=/usr/local/tomcat_xxx/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/tomcat_xxx/ -server -Xmx512m -Xms512m -XX:NewSize=64m -XX:MaxNewSize=128m -Djava.library.path=/usr/local/apr/lib -Dsun.lang.ClassLoader.allowArraySyntax=true -Djava.net.preferIPv4Stack=true -XX:PermSize=64M -XX:MaxPermSize=378m -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=7080 -Dcom.sun.management.jmxremote -classpath /usr/local/tomcat_igoal/bin/bootstrap.jar -Dcatalina.base=/usr/local/tomcat_igoal -Dcatalina.home=/usr/local/tomcat_igoal -Djava.io.tmpdir=/usr/local/tomcat_igoal/temp org.apache.catalina.startup.Bootstrap start</span><br></pre></td></tr></table></figure></li><li><p>打印jstack日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx ~]# jstack -l 142 &gt; /tmp/jstack.txt</span><br></pre></td></tr></table></figure></li></ol><p>jstack.txt 文件中的内容很多， 根据关键字(程序中的包名或者类名 等) 找到匹配的内容分析线程状态</p><p>如何分析线程状态，可以查看我博客中的一篇文章 <a href="https://binchencoder.github.io/2018/08/31/Thread%20State/">Thread State</a></p><p>我通过查找 ‘xxx’ 关键字找到很多内容， 但是有些是正常的，就直接过滤掉。最后找到这样一段内容，发现jstack日志中大量重复出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">&quot;http-192.168.0.185-12491-600&quot; #4971 daemon prio=5 os_prio=0 tid=0x00007f59a0334000 nid=0x1e7e runnable [0x00007f58c7ffc000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.util.regex.Pattern$5.isSatisfiedBy(Pattern.java:5251)</span><br><span class="line">at java.util.regex.Pattern$5.isSatisfiedBy(Pattern.java:5251)</span><br><span class="line">at java.util.regex.Pattern$CharProperty.match(Pattern.java:3776)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4227)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.match(Pattern.java:4785)</span><br><span class="line">at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)</span><br><span class="line">at java.util.regex.Pattern$Ques.match(Pattern.java:4182)</span><br><span class="line">at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)</span><br><span class="line">at java.util.regex.Pattern$Curly.match(Pattern.java:4234)</span><br><span class="line">at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)</span><br><span class="line">at java.util.regex.Pattern$Loop.matchInit(Pattern.java:4804)</span><br><span class="line">at java.util.regex.Pattern$Prolog.match(Pattern.java:4741)</span><br><span class="line">at java.util.regex.Pattern$Begin.match(Pattern.java:3525)</span><br><span class="line">at java.util.regex.Matcher.match(Matcher.java:1270)</span><br><span class="line">at java.util.regex.Matcher.matches(Matcher.java:604)</span><br><span class="line">at com.xxx.xxx.util4sysmng.ValidateUtil.checkEmail(ValidateUtil.java:30)</span><br><span class="line">at com.xxx.xxx.register.action.RegisterController.regAccountSendVcode(RegisterController.java:538)</span><br><span class="line">at com.xxx.xxx.register.action.RegisterController$$FastClassByCGLIB$$58ed8719.invoke(&lt;generated&gt;)</span><br><span class="line">at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:191)</span><br><span class="line">at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:689)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)</span><br><span class="line">at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:80)</span><br><span class="line">at com.xxx.prometheus.aspect.PrometheusAspect.process(PrometheusAspect.java:35)</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor121.invoke(Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:497)</span><br><span class="line">at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:621)</span><br><span class="line">at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:610)</span><br><span class="line">at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:65)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:161)</span><br><span class="line">at org.springframework.aop.framework.adapter.ThrowsAdviceInterceptor.invoke(ThrowsAdviceInterceptor.java:124)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)</span><br><span class="line">at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:90)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)</span><br><span class="line">at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:622)</span><br><span class="line">at com.xxx.xxx.register.action.RegisterController$$EnhancerByCGLIB$$972a02bd.regAccountSendVcode(&lt;generated&gt;)</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor124.invoke(Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:497)</span><br><span class="line">at org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:212)</span><br><span class="line">at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:126)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:96)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:617)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:578)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:80)</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:900)</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:827)</span><br><span class="line">at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:882)</span><br><span class="line">at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:778)</span><br><span class="line">at javax.servlet.http.HttpServlet.service(HttpServlet.java:617)</span><br><span class="line">at javax.servlet.http.HttpServlet.service(HttpServlet.java:723)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)</span><br><span class="line">at com.xxx.xxx.sysmng.filter.SysmngSecurityFilter.doFilter(SysmngSecurityFilter.java:46)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)</span><br><span class="line">at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)</span><br><span class="line">at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)</span><br><span class="line">at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)</span><br><span class="line">at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127)</span><br><span class="line">at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)</span><br><span class="line">at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:615)</span><br><span class="line">at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)</span><br><span class="line">at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:293)</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:861)</span><br><span class="line">at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:606)</span><br><span class="line">at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:489)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure></p><p>通过上面这段内容分析，在正则验证时出现大量线程等待，一直消耗系统CPU，最终造成服务处于假死状态，无法响应。</p><p>定位到具体的代码，经过测试 确认是验证Email的一个正则表达式有问题。代码中使用的Email正则表达式是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([a-z0-9A-Z]+[-|\\._]?)+[a-z0-9A-Z]@([a-z0-9A-Z]+(-[a-z0-9A-Z]+)?\\.)+[a-zA-Z]&#123;2,&#125;$</span><br></pre></td></tr></table></figure></p><p>测试代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testRegexFailed() &#123;</span><br><span class="line">  String email = &quot;dnjnfslkffkjkjkslioeo9edkdjfks&quot;;</span><br><span class="line">  String regex = &quot;^([a-z0-9A-Z]+[-|_|\\\\.]?)*[a-z0-9A-Z]@([a-z0-9A-Z]+(-[a-z0-9A-Z]+)?\\\\.)+[a-z0-9A-Z]&#123;2,&#125;$&quot;;</span><br><span class="line"></span><br><span class="line">  Pattern pattern = Pattern.compile(regex);</span><br><span class="line">  Matcher matcher = pattern.matcher(email);</span><br><span class="line">  System.out.println(email + &quot; : &quot; + matcher.matches());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码会出现死循环，使我电脑消耗CPU急剧增加，我在测试过程中打印了该进程消耗系统资源的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">chenbin@chenbin-ThinkPad:~$ jps </span><br><span class="line">23617 Launcher </span><br><span class="line">21422 JUnitStarter </span><br><span class="line">chenbin@chenbin-ThinkPad:~$ top -Hp 21422</span><br><span class="line">Threads: 16 total, 1 running, 15 sleeping, 0 stopped, 0 zombie </span><br><span class="line">%Cpu(s): 30.8 us, 3.6 sy, 0.0 ni, 65.4 id, 0.1 wa, 0.0 hi, 0.1 si, 0.0 st </span><br><span class="line">KiB Mem : 7861372 total, 202784 free, 6652340 used, 1006248 buff/cache </span><br><span class="line">KiB Swap: 8076284 total, 3543620 free, 4532664 used. 872480 avail Mem </span><br><span class="line"></span><br><span class="line">PID   USER    PR NI VIRT     RES   SHR S% CPU% MEM TIME+ COMMAND </span><br><span class="line">21425 chenbin 20 0 4468684 100360 18136 R 99.7 1.3 0:22.25 java </span><br><span class="line">21422 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.00 java </span><br><span class="line">21434 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.00 java </span><br><span class="line">21435 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.00 java </span><br><span class="line">21436 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.00 java </span><br><span class="line">21437 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.00 java </span><br><span class="line">21438 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.00 java </span><br><span class="line">21439 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.00 java </span><br><span class="line">21440 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.00 java </span><br><span class="line">21441 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.00 java </span><br><span class="line">21442 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.00 java </span><br><span class="line">21443 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.88 java </span><br><span class="line">21444 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.72 java </span><br><span class="line">21445 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.09 java </span><br><span class="line">21446 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.00 java </span><br><span class="line">21447 chenbin 20 0 4468684 100360 18136 S 0.0 1.3 0:00.00 java</span><br></pre></td></tr></table></figure></p><p><strong>测试中发现</strong></p><blockquote><p>在输入的字符串比较短的时候，验证没有问题。<br>但是在输入字符较长，并且不符合email规则的时候，会出现死循环。<br>如果输入过长，但是符合这个email规则，也不会有这个问题！</p></blockquote><h2 id="结案"><a href="#结案" class="headerlink" title="结案"></a>结案</h2><p>最后我们只能修改代码，替换这个正则表达式。因为这是通过的表达式，而且比较复杂，我们就没有造轮子。直接在网上找的, 经过验证，发现这个网站提供的正则比较靠谱<br><a href="https://howtodoinjava.com/regex/java-regex-validate-email-address/" target="_blank" rel="noopener">Java Email Address Validation</a></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配 0 次，而这个括号整体又可以匹配无限次，匹配过程中可能死循环。虽然现在有些正则表达式引擎已经通过办法避免了这种情况出现死循环了，比如 .NET 的正则表达式，但是我们仍然应该尽量避免出现这种情况。如果我们在写表达式时遇到了死循环，也可以从这一点入手。</p><p><strong>正则表达式虽然使用起来很方便, 但是一定要慎用.</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jstack </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread State</title>
      <link href="/2018/08/31/Thread-State/"/>
      <url>/2018/08/31/Thread-State/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-线程状态分析"><a href="#Java-线程状态分析" class="headerlink" title="Java 线程状态分析"></a>Java 线程状态分析</h2><p>Java线程的生命周期中, 存在着六种状态. 在Thread类里有一个枚举类型State, 定义了线程的几种状态. 下图比较清晰的展示了这六种状态之间的转换关系</p><p><img src="/2018/08/31/Thread-State/Thread-state.png" alt="image"></p><ul><li><p>NEW: 线程创建之后，但是还没有启动(not yet started)。这时候它的状态就是NEW</p></li><li><p>RUNNABLE: 正在Java虚拟机下跑任务的线程的状态。在RUNNABLE状态下的线程可能会处于等待状态， 因为它正在等待一些系统资源的释放，比如IO</p></li><li><p>BLOCKED: 阻塞状态，等待锁的释放，比如线程A进入了一个synchronized方法，线程B也想进入这个方法，但是这个方法的锁已经被线程A获取了，这个时候线程B就处于BLOCKED状态</p></li><li><p>WAITING: 等待状态，处于等待状态的线程是由于执行了3个方法中的任意方法。 </p><ol><li>Object的wait方法，并且没有使用timeout参数;</li><li>Thread的join方法，没有使用timeout参数 </li><li>LockSupport的park方法。 处于waiting状态的线程会等待另外一个线程处理特殊的行为。 再举个例子，如果一个线程调用了一个对象的wait方法，那么这个线程就会处于waiting状态直到另外一个线程调用这个对象的notify或者notifyAll方法后才会解除这个状态</li></ol></li><li><p>TIMED_WAITING: 有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 </p><ol><li>Thread.sleep方法 </li><li>Object的wait方法，带有时间 </li><li>Thread.join方法，带有时间 </li><li>LockSupport的parkNanos方法，带有时间 </li><li>LockSupport的parkUntil方法，带有时间</li></ol></li></ul><p>TERMINATED: 线程中止的状态，这个线程已经完整地执行了它的任务</p><h3 id="NEW-State"><a href="#NEW-State" class="headerlink" title="NEW State"></a>NEW State</h3><p>NEW状态比较简单，实例化一个线程之后，并且这个线程没有开始执行，这个时候的状态就是NEW：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread();</span><br><span class="line">System.out.println(thread.getState()); // NEW</span><br></pre></td></tr></table></figure></p><h3 id="RUNNABLE-State"><a href="#RUNNABLE-State" class="headerlink" title="RUNNABLE State"></a>RUNNABLE State</h3><p>正在运行的状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i = 0; i &lt; Integer.MAX_VALUE; i ++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;RUNNABLE-Thread&quot;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></p><p>使用jstack查看线程状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&quot;RUNNABLE-Thread&quot; #10 prio=5 os_prio=31 tid=0x00007f8e04981000 nid=0x4f03 runnable [0x000070000124c000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">  at java.io.FileOutputStream.writeBytes(Native Method)</span><br><span class="line">  at java.io.FileOutputStream.write(FileOutputStream.java:315)</span><br><span class="line">  at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)</span><br><span class="line">  at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)</span><br><span class="line">  - locked &lt;0x000000079764cc50&gt; (a java.io.BufferedOutputStream)</span><br><span class="line">  at java.io.PrintStream.write(PrintStream.java:482)</span><br><span class="line">  - locked &lt;0x0000000797604dc0&gt; (a java.io.PrintStream)</span><br><span class="line">  at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)</span><br><span class="line">  at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)</span><br><span class="line">  at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)</span><br><span class="line">  - locked &lt;0x0000000797604d78&gt; (a java.io.OutputStreamWriter)</span><br><span class="line">  at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)</span><br><span class="line">  at java.io.PrintStream.write(PrintStream.java:527)</span><br><span class="line">  - eliminated &lt;0x0000000797604dc0&gt; (a java.io.PrintStream)</span><br><span class="line">  at java.io.PrintStream.print(PrintStream.java:597)</span><br><span class="line">  at java.io.PrintStream.println(PrintStream.java:736)</span><br><span class="line">  - locked &lt;0x0000000797604dc0&gt; (a java.io.PrintStream)</span><br><span class="line">  at study.thread.ThreadStateTest$1.run(ThreadStateTest.java:23)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure><h3 id="BLOCKED-State"><a href="#BLOCKED-State" class="headerlink" title="BLOCKED State"></a>BLOCKED State</h3><p>线程A和线程B都需要持有lock对象的锁才能调用方法。如果线程A持有锁，那么线程B处于BLOCKED状态；如果线程B持有锁，那么线程A处于BLOCKED状态。例子中使用Thread.sleep方法主要是用于调试方便：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">final Object lock = new Object();</span><br><span class="line">Thread threadA = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; invoke&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(20000l);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;BLOCKED-Thread-A&quot;);</span><br><span class="line">Thread threadB = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; invoke&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(20000l);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;BLOCKED-Thread-B&quot;);</span><br><span class="line">threadA.start();</span><br><span class="line">threadB.start();</span><br></pre></td></tr></table></figure></p><p>使用jstack查看线程状态。由于线程A先执行，线程B后执行，而且线程A执行后调用了Thread.sleep方法，所以线程A会处于TIMED_WAITING状态，线程B处于BLOCKED状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;BLOCKED-Thread-B&quot; #11 prio=5 os_prio=31 tid=0x00007fa7db8ff000 nid=0x5103 waiting for monitor entry [0x000070000134f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">  at study.thread.ThreadStateTest$3.run(ThreadStateTest.java:50)</span><br><span class="line">  - waiting to lock &lt;0x0000000795a03bf8&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">&quot;BLOCKED-Thread-A&quot; #10 prio=5 os_prio=31 tid=0x00007fa7db15a000 nid=0x4f03 waiting on condition [0x000070000124c000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">  at java.lang.Thread.sleep(Native Method)</span><br><span class="line">  at study.thread.ThreadStateTest$2.run(ThreadStateTest.java:39)</span><br><span class="line">  - locked &lt;0x0000000795a03bf8&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure></p><h3 id="WAITING-State"><a href="#WAITING-State" class="headerlink" title="WAITING State"></a>WAITING State</h3><p>Object的wait方法、Thread的join方法以及Conditon的await方法都会产生WAITING状态。</p><p>1.没有时间参数的Object的wait方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">final Object lock = new Object();</span><br><span class="line">Thread threadA = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">                System.out.println(&quot;wait over&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;WAITING-Thread-A&quot;);</span><br><span class="line">Thread threadB = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(20000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;WAITING-Thread-B&quot;);</span><br><span class="line">threadA.start();</span><br><span class="line">threadB.start();</span><br></pre></td></tr></table></figure></p><p>WAITING-Thread-A调用了lock的wait，处于WAITING状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;WAITING-Thread-B&quot; #11 prio=5 os_prio=31 tid=0x00007f8de992d800 nid=0x5103 waiting on condition [0x000070000134f000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">  at java.lang.Thread.sleep(Native Method)</span><br><span class="line">  at study.thread.ThreadStateTest$5.run(ThreadStateTest.java:84)</span><br><span class="line">  - locked &lt;0x0000000795a03e40&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">&quot;WAITING-Thread-A&quot; #10 prio=5 os_prio=31 tid=0x00007f8dea193000 nid=0x4f03 in Object.wait() [0x000070000124c000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">  at java.lang.Object.wait(Native Method)</span><br><span class="line">  - waiting on &lt;0x0000000795a03e40&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Object.wait(Object.java:502)</span><br><span class="line">  at study.thread.ThreadStateTest$4.run(ThreadStateTest.java:71)</span><br><span class="line">  - locked &lt;0x0000000795a03e40&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure></p><p>2.Thread的join方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread threadA = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(20000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Thread-A over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;WAITING-Thread-A&quot;);</span><br><span class="line">threadA.start();</span><br><span class="line">try &#123;</span><br><span class="line">    threadA.join();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主线程main处于WAITING状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;WAITING-Thread-A&quot; #10 prio=5 os_prio=31 tid=0x00007fd2d5100000 nid=0x4e03 waiting on condition [0x000070000124c000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">  at java.lang.Thread.sleep(Native Method)</span><br><span class="line">  at study.thread.ThreadStateTest$6.run(ThreadStateTest.java:103)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fd2d3815000 nid=0x1003 in Object.wait() [0x0000700000182000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">  at java.lang.Object.wait(Native Method)</span><br><span class="line">  - waiting on &lt;0x0000000795a03ec0&gt; (a java.lang.Thread)</span><br><span class="line">  at java.lang.Thread.join(Thread.java:1245)</span><br><span class="line">  - locked &lt;0x0000000795a03ec0&gt; (a java.lang.Thread)</span><br><span class="line">  at java.lang.Thread.join(Thread.java:1319)</span><br><span class="line">  at study.thread.ThreadStateTest.WAITING_join(ThreadStateTest.java:118)</span><br><span class="line">  at study.thread.ThreadStateTest.main(ThreadStateTest.java:13)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:483)</span><br><span class="line">  at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)</span><br></pre></td></tr></table></figure></p><p>3.没有时间参数的Condition的await方法</p><p>Condition的await方法跟Obejct的wait方法原理是一样的，故也是WAITING状态</p><h3 id="TIMED-WAITING-State"><a href="#TIMED-WAITING-State" class="headerlink" title="TIMED_WAITING State"></a>TIMED_WAITING State</h3><p>TIMED_WAITING状态跟TIMEING状态类似，是一个有等待时间的等待状态，不会一直等待下去。</p><p>最简单的TIMED_WAITING状态例子就是Thread的sleep方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Thread threadA = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(20000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Thread-A over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;WAITING-Thread-A&quot;);</span><br><span class="line">threadA.start();</span><br><span class="line">try &#123;</span><br><span class="line">    Thread.sleep(5000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(threadA.getState()); // TIMED_WAITING</span><br></pre></td></tr></table></figure></p><p>或者是Object的wait方法带有时间参数、Thread的join方法带有时间参数也会让线程的状态处于TIMED_WAITING状态。</p><h3 id="TERMINATED-State"><a href="#TERMINATED-State" class="headerlink" title="TERMINATED State"></a>TERMINATED State</h3><p>线程终止的状态，线程执行完成，结束生命周期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread threadA = new Thread();</span><br><span class="line">threadA.start();</span><br><span class="line">try &#123;</span><br><span class="line">    Thread.sleep(5000l);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(threadA.getState()); // TERMINATED</span><br></pre></td></tr></table></figure></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>了解线程的状态可以分析一些问题。</p><p>比如线程处于BLOCKED状态，这个时候可以分析一下是不是lock加锁的时候忘记释放了，或者释放的时机不对。导致另外的线程一直处于BLOCKED状态。</p><p>比如线程处于WAITING状态，这个时候可以分析一下notifyAll或者signalAll方法的调用时机是否不对。</p><p>java自带的jstack工具可以分析查看线程的状态、优先级、描述等具体信息。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
            <tag> Jstack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UsefulScripts-Java脚本</title>
      <link href="/2018/07/22/UsefulScripts-Java%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/07/22/UsefulScripts-Java%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#show-busy-java-threads-sh">show-busy-java-threads.sh</a><ul><li><a href="#%E7%94%A8%E6%B3%95">用法</a></li><li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li><li><a href="#%E8%B4%A1%E7%8C%AE%E8%80%85">贡献者</a></li></ul></li><li><a href="#show-duplicate-java-classes-sh">show-duplicate-java-classes</a><ul><li><a href="#%E7%94%A8%E6%B3%95-1">用法</a><ul><li><a href="#jdk%E5%BC%80%E5%8F%91%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><code>JDK</code>开发场景使用说明</a><ul><li><a href="#%E5%AF%B9%E4%BA%8E%E4%B8%80%E8%88%AC%E7%9A%84%E5%B7%A5%E7%A8%8B">对于一般的工程</a></li><li><a href="#%E5%AF%B9%E4%BA%8Eweb%E5%B7%A5%E7%A8%8B">对于<code>Web</code>工程</a></li></ul></li><li><a href="#android%E5%BC%80%E5%8F%91%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><code>Android</code>开发场景使用说明</a></li></ul></li><li><a href="#%E7%A4%BA%E4%BE%8B-1">示例</a></li><li><a href="#%E8%B4%A1%E7%8C%AE%E8%80%85-1">贡献者</a></li></ul></li><li><a href="#find-in-jars-sh">find-in-jars.sh</a><ul><li><a href="#%E7%94%A8%E6%B3%95-2">用法</a></li><li><a href="#%E7%A4%BA%E4%BE%8B-2">示例</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul></li></ul><a id="more"></a><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2 id="show-busy-java-threads-sh"><a href="#show-busy-java-threads-sh" class="headerlink" title="show-busy-java-threads.sh"></a><a href="./show-busy-java-threads.sh">show-busy-java-threads.sh</a></h2><hr><p>用于快速排查<code>Java</code>的<code>CPU</code>性能问题(<code>top us</code>值过高)，自动查出运行的<code>Java</code>进程中消耗<code>CPU</code>多的线程，并打印出其线程栈，从而确定导致性能问题的方法调用。</p><p>PS，如何操作可以参见<a href="http://weibo.com/bluedavy" target="_blank" rel="noopener">@bluedavy</a>的《分布式Java应用》的【5.1.1 cpu消耗分析】一节，说得很详细：</p><ol><li><code>top</code>命令找出有问题<code>Java</code>进程及线程<code>id</code>：<ol><li>开启线程显示模式</li><li>按<code>CPU</code>使用率排序</li><li>记下<code>Java</code>进程<code>id</code>及其<code>CPU</code>高的线程<code>id</code></li></ol></li><li>用进程<code>id</code>作为参数，<code>jstack</code>有问题的<code>Java</code>进程</li><li>手动转换线程<code>id</code>成十六进制（可以用<code>printf %x 1234</code>）</li><li>查找十六进制的线程<code>id</code>（可以用<code>grep</code>）</li><li>查看对应的线程栈</li></ol><p>查问题时，会要多次这样操作以确定问题，上面过程<strong>太繁琐太慢了</strong>。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">show-busy-java-threads.sh</span><br><span class="line"><span class="comment"># 从 所有的 Java进程中找出最消耗CPU的线程（缺省5个），打印出其线程栈。</span></span><br><span class="line"></span><br><span class="line">show-busy-java-threads.sh -c &lt;要显示的线程栈数&gt;</span><br><span class="line"></span><br><span class="line">show-busy-java-threads.sh -c &lt;要显示的线程栈数&gt; -p &lt;指定的Java Process&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">##############################</span></span><br><span class="line"><span class="comment"># 注意：</span></span><br><span class="line"><span class="comment">##############################</span></span><br><span class="line"><span class="comment"># 如果Java进程的用户 与 执行脚本的当前用户 不同，则jstack不了这个Java进程。</span></span><br><span class="line"><span class="comment"># 为了能切换到Java进程的用户，需要加sudo来执行，即可以解决：</span></span><br><span class="line">sudo show-busy-java-threads.sh</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ show-busy-java-threads.sh</span><br><span class="line">[1] Busy(57.0%) thread(23355/0x5b3b) stack of java process(23269) under user(admin):</span><br><span class="line"><span class="string">"pool-1-thread-1"</span> prio=10 tid=0x000000005b5c5000 nid=0x5b3b runnable [0x000000004062c000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at java.text.DateFormat.format(DateFormat.java:316)</span><br><span class="line">    at com.xxx.foo.services.common.DateFormatUtil.format(DateFormatUtil.java:41)</span><br><span class="line">    at com.xxx.foo.shared.monitor.schedule.AppMonitorDataAvgScheduler.run(AppMonitorDataAvgScheduler.java:127)</span><br><span class="line">    at com.xxx.foo.services.common.utils.AliTimer<span class="variable">$2</span>.run(AliTimer.java:128)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.runTask(ThreadPoolExecutor.java:886)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:908)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:662)</span><br><span class="line"></span><br><span class="line">[2] Busy(26.1%) thread(24018/0x5dd2) stack of java process(23269) under user(admin):</span><br><span class="line"><span class="string">"pool-1-thread-2"</span> prio=10 tid=0x000000005a968800 nid=0x5dd2 runnable [0x00000000420e9000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at java.util.Arrays.copyOf(Arrays.java:2882)</span><br><span class="line">    at java.lang.AbstractStringBuilder.expandCapacity(AbstractStringBuilder.java:100)</span><br><span class="line">    at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:572)</span><br><span class="line">    at java.lang.StringBuffer.append(StringBuffer.java:320)</span><br><span class="line">    - locked &lt;0x00000007908d0030&gt; (a java.lang.StringBuffer)</span><br><span class="line">    at java.text.SimpleDateFormat.format(SimpleDateFormat.java:890)</span><br><span class="line">    at java.text.SimpleDateFormat.format(SimpleDateFormat.java:869)</span><br><span class="line">    at java.text.DateFormat.format(DateFormat.java:316)</span><br><span class="line">    at com.xxx.foo.services.common.DateFormatUtil.format(DateFormatUtil.java:41)</span><br><span class="line">    at com.xxx.foo.shared.monitor.schedule.AppMonitorDataAvgScheduler.run(AppMonitorDataAvgScheduler.java:126)</span><br><span class="line">    at com.xxx.foo.services.common.utils.AliTimer<span class="variable">$2</span>.run(AliTimer.java:128)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.runTask(ThreadPoolExecutor.java:886)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:908)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的线程栈可以看出，<code>CPU</code>消耗最高的2个线程都在执行<code>java.text.DateFormat.format</code>，业务代码对应的方法是<code>shared.monitor.schedule.AppMonitorDataAvgScheduler.run</code>。可以基本确定：</p><ul><li><code>AppMonitorDataAvgScheduler.run</code>调用<code>DateFormat.format</code>次数比较频繁。</li><li><code>DateFormat.format</code>比较慢。（这个可以由<code>DateFormat.format</code>的实现确定。）</li></ul><p>多个执行几次<code>show-busy-java-threads.sh</code>，如果上面情况高概率出现，则可以确定上面的判定。<br># 因为调用越少代码执行越快，则出现在线程栈的概率就越低。</p><p>分析<code>shared.monitor.schedule.AppMonitorDataAvgScheduler.run</code>实现逻辑和调用方式，以优化实现解决问题。</p><h3 id="贡献者"><a href="#贡献者" class="headerlink" title="贡献者"></a>贡献者</h3><ul><li><a href="https://github.com/silentforce" target="_blank" rel="noopener">silentforce</a>改进此脚本，增加对环境变量<code>JAVA_HOME</code>的判断。 #15</li><li><a href="https://github.com/liuyangc3" target="_blank" rel="noopener">liuyangc3</a><ul><li>优化性能，通过<code>read -a</code>简化反复的<code>awk</code>操作 #51</li><li>发现并解决<code>jstack</code>非当前用户<code>Java</code>进程的问题 #50</li></ul></li></ul><h2 id="show-duplicate-java-classes"><a href="#show-duplicate-java-classes" class="headerlink" title="show-duplicate-java-classes"></a><a href="./show-duplicate-java-classes">show-duplicate-java-classes</a></h2><p>找出<code>Java Lib</code>（<code>Java</code>库，即<code>Jar</code>文件）或<code>Class</code>目录（类目录）中的重复类。</p><p><code>Java</code>开发的一个麻烦的问题是<code>Jar</code>冲突（即多个版本的<code>Jar</code>），或者说重复类。会出<code>NoSuchMethod</code>等的问题，还不见得当时出问题。找出有重复类的<code>Jar</code>，可以防患未然。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><ul><li>通过脚本参数指定<code>Libs</code>目录，查找目录下<code>Jar</code>文件，收集<code>Jar</code>文件中<code>Class</code>文件以分析重复类。可以指定多个<code>Libs</code>目录。<br>  注意，只会查找这个目录下<code>Jar</code>文件，不会查找子目录下<code>Jar</code>文件。因为<code>Libs</code>目录一般不会用子目录再放<code>Jar</code>，这样也避免把去查找不期望<code>Jar</code>。</li><li>通过<code>-c</code>选项指定<code>Class</code>目录，直接收集这个目录下的<code>Class</code>文件以分析重复类。可以指定多个<code>Class</code>目录。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下所有Jar中的重复类</span></span><br><span class="line">show-duplicate-java-classes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找多个指定目录下所有Jar中的重复类</span></span><br><span class="line">show-duplicate-java-classes path/to/lib_dir1 /path/to/lib_dir2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找多个指定Class目录下的重复类。 Class目录 通过 -c 选项指定</span></span><br><span class="line">show-duplicate-java-classes -c path/to/class_dir1 -c /path/to/class_dir2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找指定Class目录和指定目录下所有Jar中的重复类的Jar</span></span><br><span class="line">show-duplicate-java-classes path/to/lib_dir1 /path/to/lib_dir2 -c path/to/class_dir1 -c path/to/class_dir2</span><br></pre></td></tr></table></figure><h4 id="JDK开发场景使用说明"><a href="#JDK开发场景使用说明" class="headerlink" title="JDK开发场景使用说明"></a><code>JDK</code>开发场景使用说明</h4><p>以<code>Maven</code>作为构建工程示意过程。</p><h5 id="对于一般的工程"><a href="#对于一般的工程" class="headerlink" title="对于一般的工程"></a>对于一般的工程</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在项目模块目录下执行，拷贝依赖Jar到目录target/dependency下</span></span><br><span class="line">$ mvn dependency:copy-dependencies -DincludeScope=runtime</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 检查重复类</span></span><br><span class="line">$ show-duplicate-java-classes target/dependency</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="对于Web工程"><a href="#对于Web工程" class="headerlink" title="对于Web工程"></a>对于<code>Web</code>工程</h5><p>对于<code>Web</code>工程，即<code>war</code> <code>maven</code>模块，会打包生成<code>war</code>文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在war模块目录下执行，生成war文件</span></span><br><span class="line">$ mvn install</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 解压war文件，war文件中包含了应用的依赖的Jar文件</span></span><br><span class="line">$ unzip target/*.war -d target/war</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 检查重复类</span></span><br><span class="line">$ show-duplicate-java-classes -c target/war/WEB-INF/classes target/war/WEB-INF/lib</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="Android开发场景使用说明"><a href="#Android开发场景使用说明" class="headerlink" title="Android开发场景使用说明"></a><code>Android</code>开发场景使用说明</h4><p><code>Android</code>开发，有重复类在编译打包时会报<code>[Dex Loader] Unable to execute dex: Multiple dex files define Lorg/foo/xxx/Yyy</code>。</p><p>但只会给出一个重复类名，如果重复类比较多时，上面打包/报错/排查会要进行多次，而<code>Android</code>的打包比较费时，这个过程比较麻烦，希望可以一次把所有重复类都列出来，一起排查掉。</p><p>以<code>Gradle</code>作为构建工程示意过程。</p><p>在<code>App</code>的<code>build.gradle</code>中添加拷贝库到目录<code>build/dependencies</code>下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">copyDependencies</span><span class="params">(type: Copy)</span> </span>&#123;</span><br><span class="line">    def dest = <span class="keyword">new</span> File(buildDir, <span class="string">"dependencies"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clean dir</span></span><br><span class="line">    dest.deleteDir()</span><br><span class="line">    dest.mkdirs()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill dir with dependencies</span></span><br><span class="line">    from configurations.compile into dest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝依赖</span></span><br><span class="line">$ ./gradlew app:copyDependencies</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 检查重复类</span></span><br><span class="line">$ show-duplicate-java-classes app/build/dependencies</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ show-duplicate-java-classes WEB-INF/lib</span><br><span class="line">COOL! No duplicate classes found!</span><br><span class="line"></span><br><span class="line">================================================================================</span><br><span class="line">class paths to find:</span><br><span class="line">================================================================================</span><br><span class="line">1  : WEB-INF/lib/sourceforge.spring.modules.context-2.5.6.SEC02.jar</span><br><span class="line">2  : WEB-INF/lib/misc.htmlparser-0.0.0.jar</span><br><span class="line">3  : WEB-INF/lib/normandy.client-1.0.2.jar</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ show-duplicate-java-classes -c WEB-INF/classes WEB-INF/lib</span><br><span class="line">Found duplicate classes <span class="keyword">in</span> below class path:</span><br><span class="line">1  (293@2): WEB-INF/lib/sourceforge.spring-2.5.6.SEC02.jar WEB-INF/lib/sourceforge.spring.modules.orm-2.5.6.SEC02.jar</span><br><span class="line">2  (2@3): WEB-INF/lib/servlet-api-3.0-alpha-1.jar WEB-INF/lib/jsp-api-2.1-rev-1.jar WEB-INF/lib/jstl-api-1.2-rev-1.jar</span><br><span class="line">3  (104@2): WEB-INF/lib/commons-io-2.2.jar WEB-INF/lib/jakarta.commons.io-2.0.jar</span><br><span class="line">4  (6@3): WEB-INF/lib/jakarta.commons.logging-1.1.jar WEB-INF/lib/commons-logging-1.1.1.jar WEB-INF/lib/org.slf4j.jcl104-over-slf4j-1.5.6.jar</span><br><span class="line">5  (344@2): WEB-INF/lib/sourceforge.spring-2.5.6.SEC02.jar WEB-INF/lib/sourceforge.spring.modules.context-2.5.6.SEC02.jar</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">================================================================================</span><br><span class="line">Duplicate classes detail info:</span><br><span class="line">================================================================================</span><br><span class="line">1  (293@2): WEB-INF/lib/sourceforge.spring-2.5.6.SEC02.jar WEB-INF/lib/sourceforge.spring.modules.orm-2.5.6.SEC02.jar</span><br><span class="line">    1   org/springframework/orm/toplink/TopLinkTemplate<span class="variable">$13</span>.class</span><br><span class="line">    2   org/springframework/orm/hibernate3/HibernateTemplate<span class="variable">$24</span>.class</span><br><span class="line">    3   org/springframework/orm/jpa/vendor/HibernateJpaDialect.class</span><br><span class="line">    4   org/springframework/orm/hibernate3/TypeDefinitionBean.class</span><br><span class="line">    5   org/springframework/orm/hibernate3/SessionHolder.class</span><br><span class="line">    ...</span><br><span class="line">2  (2@3): WEB-INF/lib/servlet-api-3.0-alpha-1.jar WEB-INF/lib/jsp-api-2.1-rev-1.jar WEB-INF/lib/jstl-api-1.2-rev-1.jar</span><br><span class="line">    1   javax/servlet/ServletException.class</span><br><span class="line">    2   javax/servlet/ServletContext.class</span><br><span class="line">3  (104@2): WEB-INF/lib/commons-io-2.2.jar WEB-INF/lib/jakarta.commons.io-2.0.jar</span><br><span class="line">    1   org/apache/commons/io/input/ProxyReader.class</span><br><span class="line">    2   org/apache/commons/io/output/FileWriterWithEncoding.class</span><br><span class="line">    3   org/apache/commons/io/output/TaggedOutputStream.class</span><br><span class="line">    4   org/apache/commons/io/filefilter/NotFileFilter.class</span><br><span class="line">    5   org/apache/commons/io/filefilter/TrueFileFilter.class</span><br><span class="line">    ...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">================================================================================</span><br><span class="line">class paths to find:</span><br><span class="line">================================================================================</span><br><span class="line">1  : WEB-INF/lib/sourceforge.spring.modules.context-2.5.6.SEC02.jar</span><br><span class="line">2  : WEB-INF/lib/misc.htmlparser-0.0.0.jar</span><br><span class="line">3  : WEB-INF/lib/normandy.client-1.0.2.jar</span><br><span class="line">4  : WEB-INF/lib/xml.xmlgraphics__batik-css-1.7.jar-1.7.jar</span><br><span class="line">5  : WEB-INF/lib/jakarta.ecs-1.4.2.jar</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="贡献者-1"><a href="#贡献者-1" class="headerlink" title="贡献者"></a>贡献者</h3><p><a href="https://github.com/tg123" target="_blank" rel="noopener">tgic</a>提供此脚本。友情贡献者的链接<a href="http://commandlinefu.cn/" target="_blank" rel="noopener">commandlinefu.cn</a>|<a href="http://weibo.com/u/2674868673" target="_blank" rel="noopener">微博linux命令行精选</a></p><h2 id="find-in-jars-sh"><a href="#find-in-jars-sh" class="headerlink" title="find-in-jars.sh"></a><a href="./find-in-jars.sh">find-in-jars.sh</a></h2><p>在当前目录下所有<code>jar</code>文件里，查找类或资源文件。</p><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find-in-jars.sh <span class="string">'log4j\.properties'</span></span><br><span class="line">find-in-jars.sh <span class="string">'log4j\.xml$'</span> -d /path/to/find/directory</span><br><span class="line">find-in-jars.sh log4j\\.xml</span><br><span class="line">find-in-jars.sh <span class="string">'log4j\.properties|log4j\.xml'</span></span><br></pre></td></tr></table></figure><p>注意，后面Pattern是<code>grep</code>的 <strong>扩展</strong>正则表达式。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./find-in-jars <span class="string">'Service.class$'</span></span><br><span class="line">./WEB-INF/libs/spring-2.5.6.SEC03.jar!org/springframework/stereotype/Service.class</span><br><span class="line">./rpc-benchmark-0.0.1-SNAPSHOT.jar!com/taobao/rpc/benchmark/service/HelloService.class</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://oldratlee.com/458/tech/shell/find-file-in-jar-zip-files.html" target="_blank" rel="noopener">在多个Jar(Zip)文件查找Log4J配置文件的Shell命令行</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gRPC Status and HTTP Code Relation</title>
      <link href="/2018/07/22/GRPC-Status-HTTP-Status/"/>
      <url>/2018/07/22/GRPC-Status-HTTP-Status/</url>
      
        <content type="html"><![CDATA[<ul><li>Status.INVALID_ARGUMENT <strong>[400]</strong></li><li>Status.OK <strong>[200]</strong></li><li>Status.CANCELLED <strong>[408]</strong></li><li>Status.UNKNOWN <strong>[500]</strong></li><li>Status.DEADLINE_EXCEEDED <strong>[408]</strong></li><li>Status.NOT_FOUND <strong>[404]</strong></li><li>Status.ALREADY_EXISTS <strong>[409]</strong></li><li>Status.PERMISSION_DENIED <strong>[403]</strong></li><li>Status.RESOURCE_EXHAUSTED <strong>[403]</strong></li><li>Status.FAILED_PRECONDITION <strong>[412]</strong></li><li>Status.ABORTED <strong>[409]</strong></li><li>Status.OUT_OF_RANGE <strong>[400]</strong></li><li>Status.UNIMPLEMENTED <strong>[501]</strong></li><li>Status.INTERNAL <strong>[500]</strong></li><li>Status.UNAVAILABLE <strong>[503]</strong></li><li>Status.DATA_LOSS <strong>[500]</strong></li><li>Status.UNAUTHENTICATED <strong>[401]</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gRPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo配合搭建github个人主页</title>
      <link href="/2018/07/21/Hexo%E6%90%AD%E5%BB%BAgithub%E4%B8%BB%E9%A1%B5/"/>
      <url>/2018/07/21/Hexo%E6%90%AD%E5%BB%BAgithub%E4%B8%BB%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“工欲善其事，必先利其器”，在搭建个人博客的过程中，我深刻体会到这句话的含义。虽然早就决定了要搭建个人博客，但是我并没有草草动手，而是提前做了大量的调研工作，包括采用哪种博客系统、选择哪种主题、怎么购买并绑定个性域名等等。事实证明，正因为前期的充分准备，搭建过程才能按部就班地进行。下面先介绍为何选择GitHub Pages和Hexo来搭建博客</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>Node js环境</li><li>Git环境</li></ul><a id="more"></a><p>检查环境安装是否正确<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chenbin@chenbin-ThinkPad:~$ node -v</span><br><span class="line">v8.9.4</span><br><span class="line"></span><br><span class="line">chenbin@chenbin-ThinkPad:~$ npm -v</span><br><span class="line">5.6.0</span><br><span class="line"></span><br><span class="line">chenbin@chenbin-ThinkPad:~$ git --version</span><br><span class="line">git version 2.17.1</span><br></pre></td></tr></table></figure></p><p>如果结果如上, 则说明安装正确， 可以进行下一步了。 如果不正确， 则需要回头检查自己的安装过程</p><h2 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>Link:<br><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/index.html</a></p><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><blockquote><p>NOTE:</p><p>Init <folder> 必须是完全空的目录. 不能存在任何文件, 包括隐藏文件</folder></p></blockquote><p>新建完成后，指定文件夹的目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></p><h2 id="查看建站效果"><a href="#查看建站效果" class="headerlink" title="查看建站效果"></a>查看建站效果</h2><p>自动根据当前目录下文件,生成静态网页<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></p><p>运行本地服务, 出现以下结果说明本地服务运行成功. 这时就可以在浏览器输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以看到效果了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">chenbin@chenbin-ThinkPad:~/.../github-workspace/Hexo-code$ hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p><p>效果图:<br><img src="/2018/07/21/Hexo搭建github主页/bloghexo5.png" alt="hello-world"></p><h2 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h2><p>Hexo提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br></pre></td></tr></table></figure></p><p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo:</span><br><span class="line">- type: heroku</span><br><span class="line">  repo:</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>缩进</strong></p><p>YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。</p></blockquote><p>详细说明请查看:<br><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/configuration.html</a></p><h3 id="Git-Deploy"><a href="#Git-Deploy" class="headerlink" title="Git Deploy"></a>Git Deploy</h3><p>以下是我在本地使用Git Deploy配置的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/binchencoder/binchencoder.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><h4 id="Install-Git-Deployer"><a href="#Install-Git-Deployer" class="headerlink" title="Install Git Deployer"></a>Install Git Deployer</h4><p>安装 hexo-deployer-git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>安装成功之后就可以使用Git将网站部署到指定的服务器上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chenbin@chenbin-ThinkPad:~/.../github-workspace/Hexo-code$ hexo deploy</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">INFO  Copying files from extend dirs...</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line">To https://github.com/binchencoder/binchencoder.github.io.git</span><br><span class="line">   8a8903c..dac6bed  HEAD -&gt; master</span><br><span class="line">分支 &apos;master&apos; 设置为跟踪来自 &apos;https://github.com/binchencoder/binchencoder.github.io.git&apos; 的远程分支 &apos;master&apos;。</span><br><span class="line">INFO  Deploy done: git</span><br></pre></td></tr></table></figure></p><blockquote><p>出现如上结果，就大功告成了。</p><p>Hexo Hello-World网站已经部署到Git服务上。就可以通过<a href="https://binchencode.github.io" target="_blank" rel="noopener">https://binchencode.github.io</a> 地址访问部署的网站了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub-Pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/21/hello-world/"/>
      <url>/2018/07/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> Hello World </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Hello World </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
